<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triffel (LCARS Edition)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <style>
        :root {
            --lcars-bg: #000000;
            --lcars-blue: #6699FF;
            --lcars-orange: #FF9900;
            --lcars-purple: #CC99FF;
            --lcars-tan: #FFCC99;
            --lcars-text: #E0E0E0;
            --lcars-purple-translucent: rgba(204, 153, 255, 0.4);
            --lcars-red: #CC0000;
            --lcars-red-hover: #FF3333;
            --lcars-filled-bg: #2A2A2A; 
            --lcars-filled-text: #E0E0E0;
            --lcars-filled-border: #444444;
            --lcars-divider-color: #6699FF;
        }
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--lcars-bg);
            color: var(--lcars-text);
            overflow-x: hidden;
        }
        .lcars-container {
            background-color: var(--lcars-bg);
            border: 2px solid var(--lcars-blue);
            border-radius: 1rem;
            padding: 1rem;
        }
        .dice-container {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        .dice {
            width: 60px;
            height: 60px;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: var(--lcars-tan);
            color: var(--lcars-bg);
            border: 2px solid var(--lcars-orange);
            padding: 0.5rem;
            position: relative;
        }
        .dice.kept {
            background-color: var(--lcars-purple);
            border-color: var(--lcars-tan);
        }
        .dice.rolling {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) infinite;
        }
        .lock-icon {
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            display: none;
        }
        .dice.kept .lock-icon {
            display: block;
        }
        .die-face { width: 100%; height: 100%; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 4px; }
        .die-face .dot { background-color: var(--lcars-bg); border-radius: 50%; }
        .face-1 { grid-template-areas: ". . ." ". a ." ". . ."; } .face-1 .dot:nth-child(1) { grid-area: a; }
        .face-2 { grid-template-areas: "a . ." ". . ." ". . b"; } .face-2 .dot:nth-child(1) { grid-area: a; } .face-2 .dot:nth-child(2) { grid-area: b; }
        .face-3 { grid-template-areas: "a . ." ". b ." ". . c"; } .face-3 .dot:nth-child(1) { grid-area: a; } .face-3 .dot:nth-child(2) { grid-area: b; } .face-3 .dot:nth-child(3) { grid-area: c; }
        .face-4 { grid-template-areas: "a . b" ". . ." "c . d"; } .face-4 .dot:nth-child(1) { grid-area: a; } .face-4 .dot:nth-child(2) { grid-area: b; } .face-4 .dot:nth-child(3) { grid-area: c; } .face-4 .dot:nth-child(4) { grid-area: d; }
        .face-5 { grid-template-areas: "a . b" ". c ." "d . e"; } .face-5 .dot:nth-child(1) { grid-area: a; } .face-5 .dot:nth-child(2) { grid-area: b; } .face-5 .dot:nth-child(3) { grid-area: c; } .face-5 .dot:nth-child(4) { grid-area: d; } .face-5 .dot:nth-child(5) { grid-area: e; }
        .face-6 { grid-template-areas: "a . b" "c . d" "e . f"; } .face-6 .dot:nth-child(1) { grid-area: a; } .face-6 .dot:nth-child(2) { grid-area: b; } .face-6 .dot:nth-child(3) { grid-area: c; } .face-6 .dot:nth-child(4) { grid-area: d; } .face-6 .dot:nth-child(5) { grid-area: e; } .face-6 .dot:nth-child(6) { grid-area: f; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0) rotate(-2deg); } 20%, 80% { transform: translate3d(2px, 0, 0) rotate(2deg); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0) rotate(-4deg); } 40%, 60% { transform: translate3d(4px, 0, 0) rotate(4deg); } }
        .lcars-button { background-color: var(--lcars-blue); color: var(--lcars-bg); font-weight: 700; padding: 0.75rem 1.5rem; border: none; cursor: pointer; transition: background-color 0.2s; border-radius: 0.5rem; display: flex; align-items: center; gap: 0.5rem; }
        .lcars-button:hover:not(:disabled) { background-color: var(--lcars-purple); }
        .lcars-button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
        .score-cell { min-width: 40px; height: 36px; text-align: center; vertical-align: middle; font-weight: 700; transition: background-color 0.2s; border-color: #333; }
        .score-cell.available { cursor: pointer; }
        .score-cell.available.potential-score { background-color: var(--lcars-purple-translucent); }
        .score-cell.available.potential-score:hover { background-color: var(--lcars-purple); }
        .score-cell.available[data-player="player"]:not(.potential-score):not(.strikeable) { background-color: var(--lcars-blue); color: var(--lcars-bg); }
        .score-cell.available[data-player="player"]:not(.potential-score):not(.strikeable):hover { background-color: var(--lcars-purple); }
        .score-cell.filled:not(.struck) {
            background-color: var(--lcars-filled-bg);
            color: var(--lcars-filled-text);
            border-color: var(--lcars-filled-border);
        }
        .score-cell.strikeable { background-color: var(--lcars-red); color: var(--lcars-text); }
        .score-cell.strikeable:hover { background-color: var(--lcars-red-hover); }
        .score-cell.ai-thinking { background-color: var(--lcars-purple); color: var(--lcars-bg); transition: background-color 0.1s ease-in; }
        .score-cell.struck { text-decoration: line-through; color: #888; background-color: var(--lcars-filled-bg); }
        .category-name { font-weight: 600; text-align: left; padding: 0.5rem; background-color: var(--lcars-filled-bg); color: var(--lcars-filled-text); border-radius: 1rem 0 0 1rem; }
        .player-header { background-color: var(--lcars-orange); color: var(--lcars-bg); padding: 0.5rem; font-size: 1rem; transition: background-color 0.3s ease-in-out, box-shadow 0.5s; }
        #player-header-p2 { background-color: var(--lcars-orange); }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(102, 153, 255, 0.7); } 70% { box-shadow: 0 0 10px 15px rgba(102, 153, 255, 0); } 100% { box-shadow: 0 0 0 0 rgba(102, 153, 255, 0); } }
        .player-header.active-player { background-color: var(--lcars-blue); animation: pulse 2s infinite; }
        .total-row { font-weight: bold; background-color: #222; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 50; transition: opacity 0.5s; }
        .modal-content { background-color: transparent; border: none; text-align: center; }
        .setup-input { width: 100%; padding: 0.75rem; border-radius: 0; background-color: var(--lcars-bg); border: 2px solid var(--lcars-tan); color: var(--lcars-tan); margin-bottom: 1rem; }
        .boarding-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; justify-content: center; align-items: center; flex-direction: column; opacity: 0; visibility: hidden; transition: opacity 0.5s, visibility 0.5s; }
        .boarding-screen.active { opacity: 1; visibility: visible; }
        .boarding-text { color: var(--lcars-blue); font-size: 1.5rem; margin: 0.5rem; text-shadow: 0 0 5px var(--lcars-blue); opacity: 0; transition: opacity 0.5s; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: var(--lcars-orange); opacity: 0; z-index: 100; border-radius: 50%; }
        /* Divider Styles */
        .player-divider {
            border-left-width: 3px !important;
            border-left-color: var(--lcars-divider-color) !important;
        }
        .section-divider > td {
            border-top-width: 3px !important;
            border-top-color: var(--lcars-divider-color) !important;
        }
        .corner-button {
            min-width: auto;
            padding: 0.5rem;
            border-radius: 9999px;
            width: 48px;
            height: 48px;
            justify-content: center;
        }
    </style>
</head>
<body class="p-4 md:p-8 relative">

    <div id="score-button-container" style="position: absolute; top: 1rem; left: 1rem; z-index: 40;">
        <button id="show-score-button" class="lcars-button corner-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
        </button>
    </div>
    <div id="help-button-container" style="position: absolute; top: 1rem; right: 1rem; z-index: 40;">
        <button id="help-button" class="lcars-button corner-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
        </button>
    </div>

    <!-- Setup Screen -->
    <div id="setup-screen" class="modal-backdrop flex">
        <div class="modal-content w-full max-w-md">
            <h1 class="text-3xl font-bold mb-6 text-white">TRIFFEL</h1>
            <div id="setup-form">
                <label for="player-name" class="block mb-2 font-bold text-left text-lcars-tan">CAPTAIN'S NAME:</label>
                <input type="text" id="player-name" class="setup-input" value="kleinski">
                <button id="start-game-button" class="w-full mt-4 lcars-button justify-center">MISSION STARTEN</button>
            </div>
        </div>
    </div>
    
    <!-- Boarding Screen -->
    <div id="boarding-screen" class="boarding-screen">
        <div id="boarding-text-container"></div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="max-w-7xl mx-auto hidden">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-lcars-orange">TRIFFEL</h1>
        <div class="lcars-container mb-6">
            <div class="flex flex-col items-center p-4">
                <div id="dice-area" class="w-full">
                    <div id="rolls-left-icons" class="flex justify-center gap-2 mb-2 h-8"></div>
                    <div class="dice-container">
                        <div class="dice" data-index="0">?</div><div class="dice" data-index="1">?</div><div class="dice" data-index="2">?</div><div class="dice" data-index="3">?</div><div class="dice" data-index="4">?</div>
                    </div>
                </div>
                 <div class="mt-4 h-12 flex justify-center">
                    <button id="roll-button" class="lcars-button">WÜRFELN</button>
                </div>
            </div>
        </div>
        <div class="lcars-container">
            <table id="scoreboard" class="w-full border-collapse">
                <thead id="scoreboard-header"></thead>
                <tbody id="scoreboard-body"></tbody>
            </table>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 id="winner-info" class="text-2xl font-bold mb-4 text-lcars-orange"></h2>
            <p id="final-scores" class="text-lg mb-6"></p>
            <button id="new-game-button" class="lcars-button justify-center">NEUE MISSION</button>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="help-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-2xl lcars-container">
            <h2 class="text-2xl font-bold mb-4 text-lcars-orange">SPIELREGELN</h2>
            <div class="text-left text-lcars-tan space-y-4 text-sm md:text-base">
                <p><strong class="text-lcars-blue">ZIEL:</strong> Erreiche die höchste Gesamtpunktzahl. Die Endpunktzahl ist die Summe der gewichteten Spaltenergebnisse.</p>
                <div>
                    <p class="text-lcars-blue font-bold">SPIELABLAUF:</p>
                     <ul class="list-disc list-inside ml-4 space-y-1">
                        <li>Du hast bis zu 3 Würfe pro Zug.</li>
                        <li>Nach jedem Wurf kannst du ein Ergebnis eintragen, indem du auf ein verfügbares Feld klickst.</li>
                        <li>Nach dem 1. und 2. Wurf werden dir Felder, in denen du punkten könntest, nur <strong style="color: var(--lcars-purple-translucent); background-color: #555; padding: 0 4px;">farblich markiert</strong>. Felder mit 0 Punkten werden nicht angezeigt.</li>
                        <li>Nach dem 3. Wurf (oder wenn du alle Würfel behältst), werden dir die finalen Punktwerte und die 'X'-Option zum Streichen angezeigt.</li>
                    </ul>
                </div>
                <div>
                    <p class="text-lcars-blue font-bold">SPALTENREGELN:</p>
                    <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong class="text-lcars-orange">Spalte 1 (x1):</strong> Normal. Jeder Wurf kann in jedes freie Feld eingetragen werden.</li>
                        <li><strong class="text-lcars-orange">Spalte 2 (x2):</strong> Strikt von Oben nach Unten. Du musst das oberste freie Feld füllen.</li>
                        <li><strong class="text-lcars-orange">Spalte 3 (x2):</strong> Strikt von Unten nach Oben. Du musst das unterste freie Feld füllen.</li>
                        <li><strong class="text-lcars-orange">Spalte 4 (x3):</strong> Nur Erstwürfe. Die Option, hier Punkte einzutragen, verfällt, sobald du ein zweites Mal würfelst. Du kannst das Feld aber am Ende deines Zuges noch streichen.</li>
                    </ul>
                </div>
            </div>
            <button id="close-help-button" class="w-1/2 mt-6 lcars-button justify-center">VERSTANDEN</button>
        </div>
    </div>

    <!-- Score Modal -->
    <div id="score-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-lg lcars-container">
            <h2 class="text-2xl font-bold mb-4 text-lcars-orange">PUNKTEÜBERSICHT</h2>
            <div id="score-modal-content" class="text-lg"></div>
            <button id="close-score-button" class="w-1/2 mt-6 lcars-button justify-center">SCHLIESSEN</button>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM ELEMENTS ---
    const setupScreen = document.getElementById('setup-screen');
    const gameContainer = document.getElementById('game-container');
    const startGameButton = document.getElementById('start-game-button');
    const playerNameInput = document.getElementById('player-name');
    const rollButton = document.getElementById('roll-button');
    const diceElements = document.querySelectorAll('.dice');
    const scoreboardHeader = document.getElementById('scoreboard-header');
    const scoreboardBody = document.getElementById('scoreboard-body');
    const rollsLeftIcons = document.getElementById('rolls-left-icons');
    const gameOverModal = document.getElementById('game-over-modal');
    const winnerInfo = document.getElementById('winner-info');
    const finalScores = document.getElementById('final-scores');
    const newGameButton = document.getElementById('new-game-button');
    const boardingScreen = document.getElementById('boarding-screen');
    const boardingTextContainer = document.getElementById('boarding-text-container');
    const helpButton = document.getElementById('help-button');
    const helpModal = document.getElementById('help-modal');
    const closeHelpButton = document.getElementById('close-help-button');
    const showScoreButton = document.getElementById('show-score-button');
    const scoreModal = document.getElementById('score-modal');
    const scoreModalContent = document.getElementById('score-modal-content');
    const closeScoreButton = document.getElementById('close-score-button');

    // --- GAME STATE & CONSTANTS ---
    let state = {};
    let computerVoice, confirmBeep, warpSound, shaker, singleHit, shakeLoop, computerChatter, computerChatterSeq;
    const CATEGORIES = [
        { id: 'ones', name: 'Einser' }, { id: 'twos', name: 'Zweier' }, { id: 'threes', name: 'Dreier' },
        { id: 'fours', name: 'Vierer' }, { id: 'fives', name: 'Fünfer' }, { id: 'sixes', name: 'Sechser' },
        { id: 'upperTotal', name: 'Summe Oben', isTotal: true }, { id: 'bonus', name: 'Bonus (63+)', isTotal: true },
        { id: 'upperGrandTotal', name: 'Gesamt Oben', isTotal: true }, { id: 'threeOfAKind', name: '3er-Pasch' },
        { id: 'fourOfAKind', name: '4er-Pasch' }, { id: 'Full House', name: 'Full House' },
        { id: 'smallStraight', name: 'Kl. Straße' }, { id: 'largeStraight', name: 'Gr. Straße' },
        { id: 'kniffel', name: 'TRIFFEL' }, { id: 'chance', name: 'Chance' },
        { id: 'lowerTotal', name: 'Summe Unten', isTotal: true }, { id: 'grandTotal', name: 'Gesamt', isTotal: true },
    ];
    const TOP_DOWN_ORDER = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes', 'threeOfAKind', 'fourOfAKind', 'Full House', 'smallStraight', 'largeStraight', 'kniffel', 'chance'];
    const STAR_TREK_NAMES = ['Data', 'Spock', 'Worf', 'Picard', 'Riker', 'Geordi', 'Seven of Nine', 'Janeway', 'Sisko'];
    const COLUMN_MULTIPLIERS = { col1: 1, col2: 2, col3: 2, col4: 3 };
    const dieIconSVG = `<svg width="24" height="24" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.15 28.33L50 5L94.85 28.33V71.67L50 95L5.15 71.67V28.33Z" stroke="var(--lcars-tan)" stroke-width="5"/><path d="M5.15 28.33L50 50M94.85 28.33L50 50M5.15 71.67L50 50" stroke="var(--lcars-tan)" stroke-width="3"/></svg>`;
    const lockIconSVG = `<svg class="lock-icon" viewBox="0 0 24 24"><path stroke="var(--lcars-tan)" stroke-width="2" fill="var(--lcars-bg)" d="M12 1.5A5.25 5.25 0 006.75 6.75v3H6a3 3 0 00-3 3v7.5a3 3 0 003 3h12a3 3 0 003-3v-7.5a3 3 0 00-3-3h-.75v-3A5.25 5.25 0 0012 1.5zM8.25 6.75a3.75 3.75 0 017.5 0v3H8.25v-3z"></path></svg>`;

    // --- INITIALIZATION ---
    function initGame() {
        state = {
            playerName: playerNameInput.value || 'Spieler 1',
            computerName: STAR_TREK_NAMES[Math.floor(Math.random() * STAR_TREK_NAMES.length)],
            aiDifficulty: 'hard',
            currentPlayer: 'player',
            rollsLeft: 3,
            dice: [0, 0, 0, 0, 0],
            firstRollDice: [],
            kept: [false, false, false, false, false],
            gamePhase: 'beforeRoll',
            turn: 1,
            scores: { player: createPlayerScores(), computer: createPlayerScores() },
            hasRolledMoreThanOnce: false,
        };
        gameContainer.classList.remove('hidden');
        buildScoreboard();
        startTurn();
    }

    function createPlayerScores() {
        const scores = {};
        for (let i = 1; i <= 4; i++) {
            scores[`col${i}`] = {};
            CATEGORIES.forEach(cat => { if (!cat.isTotal) scores[`col${i}`][cat.id] = null; });
        }
        return scores;
    }

    // --- AUDIO & BOARDING ---
    function setupAudio() {
        const filter = new Tone.AutoFilter("4n").toDestination().start();
        computerVoice = new Tone.AMSynth({ harmonicity: 1.5, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 } }).connect(filter);
        confirmBeep = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
        warpSound = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.1, decay: 1.5, sustain: 0, release: 0.1 } }).toDestination();
        shaker = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 } }).toDestination();
        shaker.volume.value = -20;
        singleHit = new Tone.MembraneSynth({ octaves: 4, pitchDecay: 0.1, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination();
        singleHit.volume.value = -10;
        shakeLoop = new Tone.Loop(time => { shaker.triggerAttack(time); }, "16n").start(0);
        computerChatter = new Tone.Synth({ oscillator: { type: "sawtooth" }, volume: -25, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
        const notes = ["C4", "D4", "E4", "G4", "A4", null, "E4", null];
        computerChatterSeq = new Tone.Sequence((time, note) => {
            if (note) computerChatter.triggerAttackRelease(note, "32n", time);
        }, notes, "16n").start(0);
    }
    async function playBoardingSequence() {
        setupScreen.style.opacity = 0;
        await new Promise(r => setTimeout(r, 500));
        setupScreen.classList.add('hidden');
        boardingScreen.classList.add('active');
        confirmBeep.triggerAttackRelease("C5", "8n");
        const lines = ["INITIALISIERE WARPKERN...", "SYNCHRONISIERE TRIFFEL-MATRIX...", "KALIBRIERE WAHRSCHEINLICHKEITS-ANTRIEBE...", `WILLKOMMEN AUF DER BRÜCKE, CAPTAIN ${state.playerName.toUpperCase()}`];
        for (const line of lines) {
            const p = document.createElement('p');
            p.className = 'boarding-text';
            p.textContent = line;
            boardingTextContainer.innerHTML = '';
            boardingTextContainer.appendChild(p);
            computerVoice.triggerAttackRelease("C2", "1n");
            await new Promise(r => setTimeout(r, 100));
            p.style.opacity = 1;
            await new Promise(r => setTimeout(r, 1500));
        }
        warpSound.triggerAttack();
        await new Promise(r => setTimeout(r, 500));
        boardingScreen.style.opacity = 0;
        await new Promise(r => setTimeout(r, 500));
        boardingScreen.classList.remove('active');
        initGame();
    }

    // --- UI RENDERING ---
    function createDieFace(value, index) { if (value === 0 || (state.gamePhase === 'rolling' && !state.kept[index])) { return '?'; } let dots = ''; for (let i = 0; i < value; i++) { dots += '<div class="dot"></div>'; } return `<div class="die-face face-${value}">${dots}</div>${lockIconSVG}`; }
    
    function buildScoreboard() {
        scoreboardHeader.innerHTML = `
            <tr class="border-b-2 border-lcars-blue">
                <th class="p-2 text-left">KATEGORIE</th>
                <th colspan="4" class="p-2 player-header" id="player-header-p1">${state.playerName.toUpperCase()}</th>
                <th colspan="4" class="p-2 player-header player-divider" id="player-header-p2">${state.computerName.toUpperCase()}</th>
            </tr>
            <tr class="text-xs text-lcars-tan">
                <th class="p-1"></th>
                <th class="p-1 font-normal">x1</th>
                <th class="p-1 font-normal">x2 O-U</th>
                <th class="p-1 font-normal">x2 U-O</th>
                <th class="p-1 font-normal">x3 Wurf 1</th>
                <th class="p-1 font-normal player-divider">x1</th>
                <th class="p-1 font-normal">x2 O-U</th>
                <th class="p-1 font-normal">x2 U-O</th>
                <th class="p-1 font-normal">x3 Wurf 1</th>
            </tr>`;
        scoreboardBody.innerHTML = '';
        const dividerAfterRows = ['sixes', 'upperGrandTotal', 'chance'];
        CATEGORIES.forEach(cat => {
            const row = document.createElement('tr');
            if (cat.isTotal) row.classList.add('total-row');
            if (dividerAfterRows.includes(cat.id)) {
                row.classList.add('section-divider');
            }

            row.innerHTML += `<td class="category-name">${cat.name}</td>`;
            ['player', 'computer'].forEach(player => {
                for (let i = 1; i <= 4; i++) {
                    let cellClasses = "score-cell border-l";
                    if (player === 'computer' && i === 1) {
                        cellClasses += " player-divider";
                    }
                    row.innerHTML += `<td id="${player}-${cat.id}-col${i}" class="${cellClasses}" data-player="${player}" data-category="${cat.id}" data-column="col${i}"></td>`;
                }
            });
            scoreboardBody.appendChild(row);
        });
    }

    function render() {
        diceElements.forEach((die, index) => {
            die.innerHTML = createDieFace(state.dice[index], index);
            die.classList.toggle('kept', state.kept[index]);
        });
        document.getElementById('player-header-p1').classList.toggle('active-player', state.currentPlayer === 'player');
        document.getElementById('player-header-p2').classList.toggle('active-player', state.currentPlayer === 'computer');
        rollsLeftIcons.innerHTML = Array(state.rollsLeft).fill(dieIconSVG).join('');
        rollButton.disabled = state.rollsLeft === 0 || state.gamePhase === 'rolling';
        updateAllScoresUI();
        highlightAvailableCells();
    }
    
    function updateAllScoresUI() {
        ['player', 'computer'].forEach(player => {
            for (let i = 1; i <= 4; i++) {
                const col = `col${i}`;
                let upperTotal = 0;
                let lowerTotal = 0;

                TOP_DOWN_ORDER.forEach((catId, index) => {
                    const score = state.scores[player][col][catId];
                    const cell = document.getElementById(`${player}-${catId}-${col}`);
                    if (cell) {
                        cell.classList.remove('filled', 'struck', 'available', 'strikeable', 'potential-score');
                        cell.innerHTML = ''; 

                        if (score !== null) {
                            cell.textContent = score === -1 ? 'X' : score;
                            cell.classList.add('filled');
                            if (score === -1) {
                                cell.classList.add('struck');
                            }
                        }
                    }
                    if (score > 0) {
                        if (index < 6) { upperTotal += score; } 
                        else { lowerTotal += score; }
                    }
                });

                const bonus = upperTotal >= 63 ? 35 : 0;
                const upperGrandTotal = upperTotal + bonus;
                
                document.getElementById(`${player}-upperTotal-${col}`).textContent = upperTotal;
                document.getElementById(`${player}-bonus-${col}`).textContent = bonus;
                document.getElementById(`${player}-upperGrandTotal-${col}`).textContent = upperGrandTotal;
                document.getElementById(`${player}-lowerTotal-${col}`).textContent = lowerTotal;
                document.getElementById(`${player}-grandTotal-${col}`).textContent = upperGrandTotal + lowerTotal;
            }
        });
    }

    function updateScoreModal() {
        let playerFinalTotal = 0;
        let computerFinalTotal = 0;
        let playerTotals = [];
        let computerTotals = [];

        for (let i = 1; i <= 4; i++) {
            const col = `col${i}`;
            const multiplier = COLUMN_MULTIPLIERS[col];
            
            const playerColTotal = parseInt(document.getElementById(`player-grandTotal-${col}`).textContent || '0');
            playerTotals.push(playerColTotal * multiplier);
            playerFinalTotal += playerColTotal * multiplier;

            const computerColTotal = parseInt(document.getElementById(`computer-grandTotal-${col}`).textContent || '0');
            computerTotals.push(computerColTotal * multiplier);
            computerFinalTotal += computerColTotal * multiplier;
        }

        scoreModalContent.innerHTML = `
            <table class="w-full text-center">
                <thead>
                    <tr>
                        <th></th>
                        <th class="p-2">${state.playerName.toUpperCase()}</th>
                        <th class="p-2">${state.computerName.toUpperCase()}</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td class="text-left p-2">Spalte 1 (x1)</td><td>${playerTotals[0]}</td><td>${computerTotals[0]}</td></tr>
                    <tr><td class="text-left p-2">Spalte 2 (x2)</td><td>${playerTotals[1]}</td><td>${computerTotals[1]}</td></tr>
                    <tr><td class="text-left p-2">Spalte 3 (x2)</td><td>${playerTotals[2]}</td><td>${computerTotals[2]}</td></tr>
                    <tr><td class="text-left p-2">Spalte 4 (x3)</td><td>${playerTotals[3]}</td><td>${computerTotals[3]}</td></tr>
                    <tr class="text-lcars-orange text-2xl section-divider"><td class="text-left p-2">GESAMT</td><td>${playerFinalTotal}</td><td>${computerFinalTotal}</td></tr>
                </tbody>
            </table>
        `;
    }
    
    function highlightAvailableCells() {
        if (state.currentPlayer !== 'player' || state.gamePhase === 'beforeRoll') return;

        const isFinalScoring = state.gamePhase === 'scoring';

        const processColumn = (colNum, diceToUse, allowScoring) => {
            if (!diceToUse || diceToUse.length !== 5) return;

            const col = `col${colNum}`;
            const order = (colNum === 3) ? [...TOP_DOWN_ORDER].reverse() : TOP_DOWN_ORDER;

            for (const catId of order) {
                const cell = document.getElementById(`player-${catId}-${col}`);
                if (state.scores.player[col][catId] !== null) continue;

                let isSequentiallyAvailable = (colNum === 1 || colNum === 4) ||
                    (colNum === 2 && (TOP_DOWN_ORDER.indexOf(catId) === 0 || state.scores.player[col][TOP_DOWN_ORDER[TOP_DOWN_ORDER.indexOf(catId) - 1]] !== null)) ||
                    (colNum === 3 && (order.indexOf(catId) === 0 || state.scores.player[col][order[order.indexOf(catId) - 1]] !== null));

                if (isSequentiallyAvailable) {
                    const score = calculateScore(catId, diceToUse);
                    if (allowScoring) {
                         if (isFinalScoring) {
                            if (score > 0) {
                                cell.innerHTML = score;
                                cell.classList.add('available');
                            } else {
                                cell.innerHTML = 'X';
                                cell.classList.add('available', 'strikeable');
                            }
                        } else { // Preview mode
                            if (score > 0) {
                                cell.classList.add('available', 'potential-score');
                            }
                        }
                    } else if (isFinalScoring) { // Only allow striking
                        cell.innerHTML = 'X';
                        cell.classList.add('available', 'strikeable');
                    }
                }
                if ((colNum === 2 || colNum === 3) && isSequentiallyAvailable) break; 
            }
        };

        [1, 2, 3].forEach(colNum => processColumn(colNum, state.dice, true));
        processColumn(4, state.firstRollDice, !state.hasRolledMoreThanOnce);
    }

    // --- GAME LOGIC ---
    function startTurn() {
        state.rollsLeft = 3;
        state.kept = [false, false, false, false, false];
        state.dice = [0,0,0,0,0];
        state.firstRollDice = [];
        state.hasRolledMoreThanOnce = false;
        state.gamePhase = 'beforeRoll';
        if (state.currentPlayer === 'computer') computerTurn();
        else render();
    }
    async function animateAndRollDice(diceToRollCount) {
        const rollDuration = Math.random() * 1000 + 1500;
        if (diceToRollCount > 1) {Tone.Transport.start();shakeLoop.start(0);} 
        else if (diceToRollCount === 1) {singleHit.triggerAttackRelease("C2", "8n");}
        state.gamePhase = 'rolling';
        render();
        
        await new Promise(resolve => setTimeout(resolve, rollDuration));
        
        if (diceToRollCount > 1) {shakeLoop.stop();Tone.Transport.stop();}
        
        diceElements.forEach((die, index) => {
            if (!state.kept[index]) {
                state.dice[index] = Math.floor(Math.random() * 6) + 1;
            }
        });
    }
    
    async function rollDice() {
        if (state.rollsLeft <= 0 || state.currentPlayer !== 'player' || state.gamePhase === 'rolling') return;
        
        const diceToRollCount = state.kept.filter(k => !k).length;
        if (diceToRollCount === 0 && state.rollsLeft > 0) {
            state.rollsLeft = 0;
            state.gamePhase = 'scoring';
            render();
            return;
        }

        if (state.rollsLeft < 3) {
            state.hasRolledMoreThanOnce = true;
        }

        state.rollsLeft--;
        await animateAndRollDice(diceToRollCount);

        if (state.rollsLeft === 2) {
            state.firstRollDice = [...state.dice];
        }
        
        if (state.rollsLeft === 0) {
            state.gamePhase = 'scoring';
        } else {
            state.gamePhase = 'afterRoll';
        }
        render();
    }

    function toggleKeep(index) {if (state.gamePhase === 'rolling' || state.rollsLeft === 3) return;state.kept[index] = !state.kept[index];render();}
    function selectScore(category, column) {
        const cell = document.getElementById(`player-${category}-${column}`);
        const isStrike = cell.classList.contains('strikeable');
        const diceToUse = (column === 'col4' && !state.hasRolledMoreThanOnce) ? state.firstRollDice : state.dice;
        const score = isStrike ? -1 : calculateScore(category, diceToUse);
        
        if (score === 0 && !isStrike) return;

        state.scores.player[column][category] = score;
        if (category === 'kniffel' && score === 50) {
            triggerConfetti(cell);
        }
        endTurn();
    }
    function endTurn() {if (state.turn >= TOP_DOWN_ORDER.length * 4) {gameOver();return;}if (state.currentPlayer === 'computer') state.turn++;state.currentPlayer = state.currentPlayer === 'player' ? 'computer' : 'player';startTurn();}
    function gameOver() {state.gamePhase = 'gameOver';updateScoreModal(); let playerScore = 0; let computerScore = 0; for(let i=1; i<=4; i++){playerScore += (parseInt(document.getElementById(`player-grandTotal-col${i}`).textContent) || 0) * COLUMN_MULTIPLIERS[`col${i}`]; computerScore += (parseInt(document.getElementById(`computer-grandTotal-col${i}`).textContent) || 0) * COLUMN_MULTIPLIERS[`col${i}`];} if (playerScore > computerScore) winnerInfo.textContent = `${state.playerName.toUpperCase()} HAT GEWONNEN!`;else if (computerScore > playerScore) winnerInfo.textContent = `${state.computerName.toUpperCase()} HAT GEWONNEN!`;else winnerInfo.textContent = "UNENTSCHIEDEN!";finalScores.textContent = `ENDERGEBNIS: ${playerScore} | ${state.computerName.toUpperCase()}: ${computerScore}`;gameOverModal.classList.remove('hidden');}
    function calculateScore(category, dice) {const counts = Array(6).fill(0);let sum = 0;dice.forEach(d => { counts[d - 1]++; sum += d; });switch (category) {case 'ones': return counts[0] * 1;case 'twos': return counts[1] * 2;case 'threes': return counts[2] * 3;case 'fours': return counts[3] * 4;case 'fives': return counts[4] * 5;case 'sixes': return counts[5] * 6;case 'threeOfAKind': return counts.some(c => c >= 3) ? sum : 0;case 'fourOfAKind': return counts.some(c => c >= 4) ? sum : 0;case 'Full House': return counts.includes(3) && counts.includes(2) ? 25 : 0;case 'kniffel': return counts.some(c => c >= 5) ? 50 : 0;case 'chance': return sum;case 'smallStraight': return /1234|2345|3456/.test([...new Set(dice)].sort().join('')) ? 30 : 0;case 'largeStraight': return /12345|23456/.test([...new Set(dice)].sort().join('')) ? 40 : 0;default: return 0;}}
    function triggerConfetti(element) {if(!element) return; const rect = element.getBoundingClientRect();const colors = ['#FF9900', '#6699FF', '#CC99FF', '#FFCC99'];for (let i = 0; i < 50; i++) {const confetti = document.createElement('div');confetti.className = 'confetti';document.body.appendChild(confetti);confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];confetti.style.left = rect.left + rect.width / 2 + 'px';confetti.style.top = rect.top + rect.height / 2 + 'px';const angle = Math.random() * Math.PI * 2;const velocity = Math.random() * 50 + 50;const x = Math.cos(angle) * velocity;const y = Math.sin(angle) * velocity - 50;confetti.style.transition = 'transform 1s ease-out, opacity 1s ease-out';confetti.style.opacity = 1;setTimeout(() => {confetti.style.transform = `translate(${x}px, ${y + 100}px) rotate(360deg)`;confetti.style.opacity = 0;}, 10);setTimeout(() => { confetti.remove(); }, 1010);}}
    
    // --- NEW AI LOGIC BASED ON PSEUDOCODE ---

    async function computerTurn() {
        let rollsRemaining = 3;
        let currentDice;
        let firstRollDice = [];

        state.rollsLeft = rollsRemaining;
        state.dice = [0,0,0,0,0];
        state.kept = [false,false,false,false,false];
        render();
        await new Promise(res => setTimeout(res, 500));

        await animateAndRollDice(5);
        state.gamePhase = 'computerTurn';
        render();
        currentDice = [...state.dice];
        firstRollDice = [...state.dice];
        rollsRemaining--;

        while (rollsRemaining >= 0) {
            const { action, bestKeepDecision } = analyzeAITurn(currentDice, rollsRemaining, firstRollDice);

            if (action === 'PLACE_SCORE' || action === 'STRIKE') {
                const finalDice = currentDice;
                const possibleMoves = evaluatePlacements(finalDice, firstRollDice, rollsRemaining === 2);
                
                let bestMove;
                if (possibleMoves.length > 0) {
                    bestMove = possibleMoves.reduce((best, current) => current.efs > best.efs ? current : best);
                } else {
                    bestMove = { action: determineOptimalStrike() };
                }

                await executeComputerMove(bestMove.action, possibleMoves);
                return;

            } else if (action === 'REROLL') {
                state.kept = bestKeepDecision;
                render();
                await new Promise(res => setTimeout(res, 1200));

                const diceToRollCount = bestKeepDecision.filter(k => !k).length;
                
                if (diceToRollCount === 0 || rollsRemaining === 0) { // Should place score
                     const finalDice = currentDice;
                     const possibleMoves = evaluatePlacements(finalDice, firstRollDice, rollsRemaining === 2);
                     const bestMove = possibleMoves.length > 0 ? possibleMoves.reduce((best, current) => current.efs > best.efs ? current : best) : { action: determineOptimalStrike() };
                     await executeComputerMove(bestMove.action, possibleMoves);
                     return;
                }

                rollsRemaining--;
                state.rollsLeft = rollsRemaining;
                await animateAndRollDice(diceToRollCount);
                state.gamePhase = 'computerTurn';
                render();
                currentDice = [...state.dice];
            }
        }
    }

    function analyzeAITurn(currentDice, rollsRemaining, firstRollDice) {
        if (rollsRemaining === 0) {
            return { action: 'PLACE_SCORE' };
        }

        // Evaluate placing score now
        const bestPlacementNow = evaluatePlacements(currentDice, firstRollDice, rollsRemaining === 2)
            .reduce((max, move) => move.efs > max.efs ? move : max, { efs: -Infinity });

        // Evaluate rerolling
        let bestRerollOption = { efs: -Infinity, keep: [false,false,false,false,false] };
        
        // Simplified: Check a few promising "keep" strategies instead of all 32 subsets
        const keepStrategies = getKeepStrategies(currentDice);

        for (const keepDecision of keepStrategies) {
            const numToReroll = 5 - keepDecision.filter(k => k).length;
            if (numToReroll === 0) continue;
            
            // Simplified EFS: Heuristic value of the dice we are keeping
            const keptDice = currentDice.filter((d, i) => keepDecision[i]);
            const estimatedEfsOfReroll = estimateRerollValue(keptDice);

            if (estimatedEfsOfReroll > bestRerollOption.efs) {
                bestRerollOption = { efs: estimatedEfsOfReroll, keep: keepDecision };
            }
        }

        // Opportunistic override for first roll
        if (rollsRemaining === 2) {
            const highValueCombo = getHighValuePlacement(currentDice, firstRollDice);
            if (highValueCombo && highValueCombo.efs > bestRerollOption.efs) {
                return { action: 'PLACE_SCORE' };
            }
        }

        if (bestPlacementNow.efs > bestRerollOption.efs && bestPlacementNow.efs > -Infinity) {
            return { action: 'PLACE_SCORE' };
        } else {
            return { action: 'REROLL', bestKeepDecision: bestRerollOption.keep };
        }
    }

    function getKeepStrategies(dice) {
        const strategies = [];
        const counts = {};
        dice.forEach(d => counts[d] = (counts[d] || 0) + 1);

        // Keep pairs, 3-of-a-kind, 4-of-a-kind
        for (let num = 6; num >= 1; num--) {
            if (counts[num] >= 2) strategies.push(dice.map(d => d === num));
        }
        // Keep straights
        const uniqueSorted = [...new Set(dice)].sort();
        if (/1234|2345|3456/.test(uniqueSorted.join(''))) {
             const straight = /1234/.test(uniqueSorted.join('')) ? [1,2,3,4] : /2345/.test(uniqueSorted.join('')) ? [2,3,4,5] : [3,4,5,6];
             strategies.push(dice.map(d => straight.includes(d)));
        }
        // Keep high dice
        strategies.push(dice.map(d => d >= 5));
        // Keep nothing (reroll all)
        strategies.push([false, false, false, false, false]);

        return strategies.filter((s, i, self) => i === self.findIndex(t => JSON.stringify(t) === JSON.stringify(s)));
    }

    function estimateRerollValue(keptDice) {
        let value = 0;
        const counts = {};
        keptDice.forEach(d => counts[d] = (counts[d] || 0) + 1);
        
        const ofAKind = Math.max(0, ...Object.values(counts));
        value += Math.pow(ofAKind, 3); // Heavily weight keeping pairs/triples

        // Bonus for potential straights
        const uniqueSorted = [...new Set(keptDice)].sort();
        if (uniqueSorted.length >= 3 && uniqueSorted[uniqueSorted.length-1] - uniqueSorted[0] <= 3) {
            value += 15;
        }
        return value;
    }

    function getHighValuePlacement(dice, firstRollDice) {
         const placements = evaluatePlacements(dice, firstRollDice, true);
         const highValueCats = ['kniffel', 'largeStraight', 'fourOfAKind', 'Full House'];
         return placements.find(p => highValueCats.includes(p.action.category) && p.action.rawScore > 0);
    }

    function evaluatePlacements(dice, firstRollDice, isFirstRoll) {
        const moves = [];
        const process = (col, d, useFirstRoll) => {
            for (const catId of TOP_DOWN_ORDER) {
                if (isCellAvailableForComputer(catId, col)) {
                    const rawScore = calculateScore(catId, d);
                    if (rawScore > 0) {
                        let efs = rawScore * COLUMN_MULTIPLIERS[col];
                        // Heuristic: Add bonus for good placements
                        if (catId === 'kniffel' && rawScore > 0) efs += 50;
                        if (catId === 'largeStraight' && rawScore > 0) efs += 20;
                        if (['fives', 'sixes'].includes(catId)) efs += 5; // Push for upper bonus
                        
                        moves.push({ efs: efs, action: { rawScore, category: catId, column: col } });
                    }
                }
            }
        };
        
        process('col1', dice, false);
        process('col2', dice, false);
        process('col3', dice, false);
        if (isFirstRoll) {
            process('col4', firstRollDice, true);
        }
        
        return moves.sort((a,b) => b.efs - a.efs);
    }

    function determineOptimalStrike() {
        // Find the "least valuable" open spot to strike
        const strikePriorities = ['ones', 'twos', 'threes', 'fourOfAKind', 'kniffel', 'chance'];
        for (const col of ['col1', 'col2', 'col3', 'col4']) {
            for (const catId of strikePriorities) {
                if (isCellAvailableForComputer(catId, col)) {
                    return { rawScore: -1, category: catId, column: col };
                }
            }
        }
        // Fallback: strike the first available spot
        for (const col of ['col1', 'col2', 'col3', 'col4']) {
            for (const catId of TOP_DOWN_ORDER) {
                if (isCellAvailableForComputer(catId, col)) {
                    return { rawScore: -1, category: catId, column: col };
                }
            }
        }
        return null; // Should not be reached
    }

    function isCellAvailableForComputer(category, column) {
        if (state.scores.computer[column][category] !== null) return false;
        const colNum = parseInt(column.replace('col', ''));
        if (colNum === 1 || colNum === 4) return true;
        if (colNum === 2) {
            const index = TOP_DOWN_ORDER.indexOf(category);
            return index === 0 || state.scores.computer[column][TOP_DOWN_ORDER[index - 1]] !== null;
        }
        if (colNum === 3) {
            const reversedOrder = [...TOP_DOWN_ORDER].reverse();
            const index = reversedOrder.indexOf(category);
            return index === 0 || state.scores.computer[column][reversedOrder[index - 1]] !== null;
        }
        return false;
    }

    async function animateAIThinking(possibleMoves) {
        const thinkCount = Math.min(possibleMoves.length, 3);
        const shuffledMoves = [...possibleMoves].sort(() => 0.5 - Math.random());
        for (let i = 0; i < thinkCount; i++) {
            const move = shuffledMoves[i].action;
            if (!move) continue;
            const cell = document.getElementById(`computer-${move.category}-${move.column}`);
            if (cell) {
                cell.classList.add('ai-thinking');
                await new Promise(res => setTimeout(res, 300));
                cell.classList.remove('ai-thinking');
            }
        }
    }

    async function executeComputerMove(move, possibleMoves) {
        if (!move || !move.column || !move.category) { endTurn(); return; }

        computerChatterSeq.start(0);
        Tone.Transport.start();
        await animateAIThinking(possibleMoves);
        computerChatterSeq.stop();
        Tone.Transport.stop();

        const score = move.rawScore;
        state.scores.computer[move.column][move.category] = score;
        
        const chosenCell = document.getElementById(`computer-${move.category}-${move.column}`);
        if(chosenCell) {
            chosenCell.style.transition = 'background-color 0.2s';
            chosenCell.style.backgroundColor = 'var(--lcars-orange)';
            await new Promise(res => setTimeout(res, 1000));
            chosenCell.style.backgroundColor = '';
        }
        
        endTurn();
    }

    // --- EVENT LISTENERS ---
    startGameButton.addEventListener('click', () => {
        state.playerName = playerNameInput.value || 'Spieler 1';
        Tone.start().then(setupAudio).then(playBoardingSequence);
    });
    rollButton.addEventListener('click', rollDice);
    helpButton.addEventListener('click', () => helpModal.classList.remove('hidden'));
    closeHelpButton.addEventListener('click', () => helpModal.classList.add('hidden'));
    showScoreButton.addEventListener('click', () => {
        updateScoreModal();
        scoreModal.classList.remove('hidden');
    });
    closeScoreButton.addEventListener('click', () => scoreModal.classList.add('hidden'));
    diceElements.forEach(die => { die.addEventListener('click', () => toggleKeep(parseInt(die.dataset.index))); });
    scoreboardBody.addEventListener('click', (e) => {
        const cell = e.target.closest('.score-cell');
        if (!cell || !cell.classList.contains('available')) return;
        const { player, category, column } = cell.dataset;
        if (player !== 'player') return;
        selectScore(category, column);
    });
    newGameButton.addEventListener('click', () => {
        gameOverModal.classList.add('hidden');
        boardingTextContainer.innerHTML = '';
        setupScreen.style.opacity = 1;
        setupScreen.classList.remove('hidden');
    });
});
</script>

</body>
</html>

