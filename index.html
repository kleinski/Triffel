<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triffel (LCARS Edition)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <style>
        :root {
            --lcars-bg: #000000;
            --lcars-blue: #6699FF;
            --lcars-orange: #FF9900;
            --lcars-purple: #CC99FF;
            --lcars-tan: #FFCC99;
            --lcars-text: #E0E0E0;
            --lcars-purple-translucent: rgba(204, 153, 255, 0.4);
            --lcars-red: #CC0000;
            --lcars-red-hover: #FF3333;
            --lcars-filled-bg: #2A2A2A; 
            --lcars-filled-text: #E0E0E0;
            --lcars-filled-border: #444444;
            --lcars-divider-color: #6699FF;
        }
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--lcars-bg);
            color: var(--lcars-text);
            overflow-x: hidden;
        }
        .lcars-container {
            background-color: var(--lcars-bg);
            border: 2px solid var(--lcars-blue);
            border-radius: 1rem;
            padding: 1rem;
        }
        .dice-container {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        .dice {
            width: 60px;
            height: 60px;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: var(--lcars-tan);
            color: var(--lcars-bg);
            border: 2px solid var(--lcars-orange);
            padding: 0.5rem;
            position: relative;
        }
        .dice.kept {
            background-color: var(--lcars-purple);
            border-color: var(--lcars-tan);
        }
        @keyframes better-roll {
            0%   { transform: translateY(0px) rotate(0deg); }
            25%  { transform: translateY(-10px) rotate(90deg); }
            50%  { transform: translateY(0px) rotate(180deg); }
            75%  { transform: translateY(-5px) rotate(270deg); }
            100% { transform: translateY(0px) rotate(360deg); }
        }
        .dice.rolling {
            animation: better-roll 0.6s ease-in-out infinite;
        }
        .lock-icon {
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            display: none;
        }
        .dice.kept .lock-icon {
            display: block;
        }
        .die-face { width: 100%; height: 100%; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 4px; }
        .die-face .dot { background-color: var(--lcars-bg); border-radius: 50%; }
        .face-1 { grid-template-areas: ". . ." ". a ." ". . ."; } .face-1 .dot:nth-child(1) { grid-area: a; }
        .face-2 { grid-template-areas: "a . ." ". . ." ". . b"; } .face-2 .dot:nth-child(1) { grid-area: a; } .face-2 .dot:nth-child(2) { grid-area: b; }
        .face-3 { grid-template-areas: "a . ." ". b ." ". . c"; } .face-3 .dot:nth-child(1) { grid-area: a; } .face-3 .dot:nth-child(2) { grid-area: b; } .face-3 .dot:nth-child(3) { grid-area: c; }
        .face-4 { grid-template-areas: "a . b" ". . ." "c . d"; } .face-4 .dot:nth-child(1) { grid-area: a; } .face-4 .dot:nth-child(2) { grid-area: b; } .face-4 .dot:nth-child(3) { grid-area: c; } .face-4 .dot:nth-child(4) { grid-area: d; }
        .face-5 { grid-template-areas: "a . b" ". c ." "d . e"; } .face-5 .dot:nth-child(1) { grid-area: a; } .face-5 .dot:nth-child(2) { grid-area: b; } .face-5 .dot:nth-child(3) { grid-area: c; } .face-5 .dot:nth-child(4) { grid-area: d; } .face-5 .dot:nth-child(5) { grid-area: e; }
        .face-6 { grid-template-areas: "a . b" "c . d" "e . f"; } .face-6 .dot:nth-child(1) { grid-area: a; } .face-6 .dot:nth-child(2) { grid-area: b; } .face-6 .dot:nth-child(3) { grid-area: c; } .face-6 .dot:nth-child(4) { grid-area: d; } .face-6 .dot:nth-child(5) { grid-area: e; } .face-6 .dot:nth-child(6) { grid-area: f; }
        .lcars-button { background-color: var(--lcars-blue); color: var(--lcars-bg); font-weight: 700; padding: 0.75rem 1.5rem; border: none; cursor: pointer; transition: background-color 0.2s; border-radius: 0.5rem; display: flex; align-items: center; gap: 0.5rem; }
        .lcars-button:hover:not(:disabled) { background-color: var(--lcars-purple); }
        .lcars-button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
        .score-cell { min-width: 40px; height: 36px; text-align: center; vertical-align: middle; font-weight: 700; transition: background-color 0.2s, box-shadow 0.3s; border-color: #333; }
        .score-cell.available { cursor: pointer; }
        .score-cell.available.potential-score { background-color: var(--lcars-purple-translucent); }
        .score-cell.available.potential-score:hover { background-color: var(--lcars-purple); }
        .score-cell.available[data-player="player"]:not(.potential-score):not(.strikeable) { background-color: var(--lcars-blue); color: var(--lcars-bg); }
        .score-cell.available[data-player="player"]:not(.potential-score):not(.strikeable):hover { background-color: var(--lcars-purple); }
        .score-cell.filled:not(.struck) {
            background-color: var(--lcars-filled-bg);
            color: var(--lcars-filled-text);
            border-color: var(--lcars-filled-border);
        }
        .score-cell.strikeable { background-color: var(--lcars-red); color: var(--lcars-text); }
        .score-cell.strikeable:hover { background-color: var(--lcars-red-hover); }
        .score-cell.ai-thinking { background-color: var(--lcars-purple); color: var(--lcars-bg); transition: background-color 0.1s ease-in; }
        .score-cell.struck { text-decoration: line-through; color: #888; background-color: var(--lcars-filled-bg); }
        .score-cell.last-ai-move { box-shadow: inset 0 0 8px 2px var(--lcars-orange); }
        .category-name { font-weight: 600; text-align: left; padding: 0.5rem; background-color: var(--lcars-filled-bg); color: var(--lcars-filled-text); border-radius: 1rem 0 0 1rem; }
        .player-header { background-color: var(--lcars-filled-bg); color: var(--lcars-filled-text); padding: 0.5rem; font-size: 1rem; transition: background-color 0.3s ease-in-out, box-shadow 0.5s; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(102, 153, 255, 0.7); } 70% { box-shadow: 0 0 10px 15px rgba(102, 153, 255, 0); } 100% { box-shadow: 0 0 0 0 rgba(102, 153, 255, 0); } }
        .player-header.active-player { background-color: var(--lcars-blue); animation: pulse 2s infinite; }
        .total-row { font-weight: bold; background-color: #222; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 50; transition: opacity 0.5s; }
        .modal-content { background-color: transparent; border: none; text-align: center; }
        .setup-input { width: 100%; padding: 0.75rem; border-radius: 0; background-color: var(--lcars-bg); border: 2px solid var(--lcars-tan); color: var(--lcars-tan); margin-bottom: 1rem; }
        .boarding-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; justify-content: center; align-items: center; flex-direction: column; opacity: 0; visibility: hidden; transition: opacity 0.5s, visibility 0.5s; }
        .boarding-screen.active { opacity: 1; visibility: visible; }
        .boarding-text { color: var(--lcars-blue); font-size: 1.5rem; margin: 0.5rem; text-shadow: 0 0 5px var(--lcars-blue); opacity: 0; transition: opacity 0.5s; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: var(--lcars-orange); opacity: 0; z-index: 100; border-radius: 50%; }
        /* Divider Styles */
        .player-divider {
            border-left-width: 3px !important;
            border-left-color: var(--lcars-divider-color) !important;
        }
        .section-divider > td {
            border-top-width: 1px !important;
            border-top-color: #333 !important;
        }
        .corner-button {
            min-width: auto;
            padding: 0.5rem;
            border-radius: 9999px;
            width: 48px;
            height: 48px;
            justify-content: center;
        }
        /* Toggle Switch Styles */
        .toggle-label { display: flex; align-items: center; justify-content: space-between; cursor: pointer; width: 100%; padding: 0.5rem 0; }
        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--lcars-blue); }
        input:checked + .slider:before { transform: translateX(26px); }
        /* Range Slider Styles */
        .slider-range {
            background: #333;
            outline: none;
        }
        .slider-range::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--lcars-blue);
            cursor: pointer;
            border-radius: 50%;
        }
        .slider-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--lcars-blue);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
    </style>
</head>
<body class="p-4 md:p-8 relative">

    <!-- Setup Screen -->
    <div id="setup-screen" class="modal-backdrop flex">
        <div class="modal-content w-full max-w-md relative">
             <div style="position: absolute; top: 1rem; right: 1rem; z-index: 40;">
                <button id="settings-button-setup" class="lcars-button corner-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </button>
            </div>
            <h1 class="text-3xl font-bold mb-6 text-white">TRIFFEL</h1>
            <div id="setup-form">
                <label for="player-name" class="block mb-2 font-bold text-left text-lcars-tan">CAPTAIN'S NAME:</label>
                <input type="text" id="player-name" class="setup-input" value="kleinski">
                <button id="start-game-button" class="w-full mt-4 lcars-button justify-center">MISSION STARTEN</button>
            </div>
        </div>
    </div>
    
    <!-- Boarding Screen -->
    <div id="boarding-screen" class="boarding-screen">
        <div id="boarding-text-container"></div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="max-w-7xl mx-auto hidden">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-lcars-orange">TRIFFEL</h1>
        <div class="lcars-container mb-6">
            <div class="flex items-center justify-between p-4">
                 <div class="flex flex-col gap-2">
                    <button id="show-score-button" class="lcars-button corner-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
                    </button>
                    <button id="settings-button" class="lcars-button corner-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                    </button>
                     <button id="help-button" class="lcars-button corner-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                    </button>
                </div>

                <div class="flex flex-col items-center">
                    <div id="dice-area" class="w-full">
                        <div id="rolls-left-icons" class="flex justify-center gap-2 mb-2 h-8"></div>
                        <div class="dice-container">
                            <div class="dice" data-index="0">?</div><div class="dice" data-index="1">?</div><div class="dice" data-index="2">?</div><div class="dice" data-index="3">?</div><div class="dice" data-index="4">?</div>
                        </div>
                    </div>
                     <div class="mt-4 h-12 flex justify-center">
                        <button id="roll-button" class="lcars-button">WÜRFELN</button>
                    </div>
                </div>
                <div class="flex flex-col gap-2 justify-self-end">
                     <button id="undo-button" class="lcars-button corner-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path><polyline points="22 12 12 12 12 2"></polyline></svg>
                    </button>
                </div>
            </div>
        </div>
        <div class="lcars-container">
            <table id="scoreboard" class="w-full border-collapse">
                <thead id="scoreboard-header"></thead>
                <tbody id="scoreboard-body"></tbody>
            </table>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-lg lcars-container">
            <h2 id="winner-info" class="text-2xl font-bold mb-4 text-lcars-orange"></h2>
            <div id="final-scores-table" class="text-lg mb-6"></div>
            <button id="new-game-button" class="w-1/2 mt-6 lcars-button justify-center">NEUE MISSION</button>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="help-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-2xl lcars-container">
            <h2 class="text-2xl font-bold mb-4 text-lcars-orange">SPIELREGELN</h2>
            <div class="text-left text-lcars-tan space-y-4 text-sm md:text-base">
                <p><strong class="text-lcars-blue">ZIEL:</strong> Erreiche die höchste Gesamtpunktzahl. Die Endpunktzahl ist die Summe der gewichteten Spaltenergebnisse.</p>
                <div>
                    <p class="text-lcars-blue font-bold">SPIELABLAUF:</p>
                     <ul class="list-disc list-inside ml-4 space-y-1">
                        <li>Du hast bis zu 3 Würfe pro Zug.</li>
                        <li>Nach jedem Wurf kannst du ein Ergebnis eintragen, indem du auf ein verfügbares Feld klickst.</li>
                        <li>Nach dem 1. und 2. Wurf werden dir Felder, in denen du punkten könntest, nur <strong style="color: var(--lcars-purple-translucent); background-color: #555; padding: 0 4px;">farblich markiert</strong>. Felder mit 0 Punkten werden nicht angezeigt.</li>
                        <li>Nach dem 3. Wurf (oder wenn du alle Würfel behältst), werden dir die finalen Punktwerte und die 'X'-Option zum Streichen angezeigt.</li>
                    </ul>
                </div>
                <div>
                    <p class="text-lcars-blue font-bold">SPALTENREGELN:</p>
                    <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong class="text-lcars-orange">Spalte 1 (x1):</strong> Normal. Jeder Wurf kann in jedes freie Feld eingetragen werden.</li>
                        <li><strong class="text-lcars-orange">Spalte 2 (x2):</strong> Strikt von Oben nach Unten. Du musst das oberste freie Feld füllen.</li>
                        <li><strong class="text-lcars-orange">Spalte 3 (x2):</strong> Strikt von Unten nach Oben. Du musst das unterste freie Feld füllen.</li>
                        <li><strong class="text-lcars-orange">Spalte 4 (x3):</strong> Nur Erstwürfe. Die Option, hier Punkte einzutragen, verfällt, sobald du ein zweites Mal würfelst. Du kannst das Feld aber am Ende deines Zuges noch streichen.</li>
                    </ul>
                </div>
            </div>
            <button id="close-help-button" class="w-1/2 mt-6 lcars-button justify-center">VERSTANDEN</button>
        </div>
    </div>

    <!-- Score Modal -->
    <div id="score-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-lg lcars-container">
            <h2 class="text-2xl font-bold mb-4 text-lcars-orange">PUNKTEÜBERSICHT</h2>
            <div id="score-modal-content" class="text-lg"></div>
            <button id="close-score-button" class="w-1/2 mt-6 lcars-button justify-center">SCHLIESSEN</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-lg lcars-container">
            <h2 class="text-2xl font-bold mb-4 text-lcars-orange">EINSTELLUNGEN</h2>
            <div class="space-y-4 text-lg text-left p-4">
                <label class="toggle-label">
                    <span>Soundeffekte</span>
                    <div class="toggle-switch">
                        <input type="checkbox" id="sound-toggle" checked>
                        <span class="slider"></span>
                    </div>
                </label>
                <label class="toggle-label">
                    <span>Screenshots</span>
                    <div class="toggle-switch">
                        <input type="checkbox" id="screenshot-toggle">
                        <span class="slider"></span>
                    </div>
                </label>
                <label class="toggle-label">
                    <span>Spielprotokoll</span>
                    <div class="toggle-switch">
                        <input type="checkbox" id="log-toggle">
                        <span class="slider"></span>
                    </div>
                </label>
                
                <!-- AI Delay Settings -->
                <div class="mt-6 pt-4 border-t border-gray-600">
                    <h3 class="text-lg font-bold mb-4 text-lcars-blue">KI-GESCHWINDIGKEIT</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block mb-2 text-sm">Kurze Pausen: <span id="delay-short-value">1.0s</span></label>
                            <input type="range" id="delay-short" min="300" max="3000" step="100" value="1000" 
                                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider-range">
                        </div>
                        
                        <div>
                            <label class="block mb-2 text-sm">Mittlere Pausen: <span id="delay-medium-value">1.5s</span></label>
                            <input type="range" id="delay-medium" min="500" max="4000" step="100" value="1500" 
                                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider-range">
                        </div>
                        
                        <div>
                            <label class="block mb-2 text-sm">Lange Pausen: <span id="delay-long-value">2.0s</span></label>
                            <input type="range" id="delay-long" min="1000" max="5000" step="100" value="2000" 
                                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider-range">
                        </div>
                    </div>
                </div>
            </div>
            <button id="close-settings-button" class="w-1/2 mt-6 lcars-button justify-center">SCHLIESSEN</button>
        </div>
    </div>

    <!-- Mission Analysis Modal -->
    <div id="mission-analysis-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-lg">
            <div id="mission-analysis-text-container" class="text-left"></div>
        </div>
    </div>
    
    <!-- Undo Modal -->
    <div id="undo-modal" class="modal-backdrop hidden">
        <div class="modal-content w-full max-w-md lcars-container">
            <h2 class="text-2xl font-bold mb-4 text-lcars-orange">Reset?</h2>
            <div class="flex justify-center gap-4">
                <button id="undo-yes-button" class="lcars-button">Ja</button>
                <button id="undo-no-button" class="lcars-button" style="background-color: var(--lcars-red);">Nein</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM ELEMENTS ---
    const setupScreen = document.getElementById('setup-screen');
    const gameContainer = document.getElementById('game-container');
    const startGameButton = document.getElementById('start-game-button');
    const playerNameInput = document.getElementById('player-name');
    const rollButton = document.getElementById('roll-button');
    const diceElements = document.querySelectorAll('.dice');
    const scoreboardHeader = document.getElementById('scoreboard-header');
    const scoreboardBody = document.getElementById('scoreboard-body');
    const rollsLeftIcons = document.getElementById('rolls-left-icons');
    const gameOverModal = document.getElementById('game-over-modal');
    const winnerInfo = document.getElementById('winner-info');
    const finalScoresTable = document.getElementById('final-scores-table');
    const newGameButton = document.getElementById('new-game-button');
    const boardingScreen = document.getElementById('boarding-screen');
    const boardingTextContainer = document.getElementById('boarding-text-container');
    const helpButton = document.getElementById('help-button');
    const helpModal = document.getElementById('help-modal');
    const closeHelpButton = document.getElementById('close-help-button');
    const showScoreButton = document.getElementById('show-score-button');
    const scoreModal = document.getElementById('score-modal');
    const scoreModalContent = document.getElementById('score-modal-content');
    const closeScoreButton = document.getElementById('close-score-button');
    const missionAnalysisModal = document.getElementById('mission-analysis-modal');
    const missionAnalysisTextContainer = document.getElementById('mission-analysis-text-container');
    const settingsButton = document.getElementById('settings-button');
    const settingsButtonSetup = document.getElementById('settings-button-setup');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsButton = document.getElementById('close-settings-button');
    const soundToggle = document.getElementById('sound-toggle');
    const screenshotToggle = document.getElementById('screenshot-toggle');
    const logToggle = document.getElementById('log-toggle');
    const undoButton = document.getElementById('undo-button');
    const undoModal = document.getElementById('undo-modal');
    const undoYesButton = document.getElementById('undo-yes-button');
    const undoNoButton = document.getElementById('undo-no-button');

    // --- GAME STATE & CONSTANTS ---
    let state = {};
    let globalSettings = {
        sound: true,
        screenshots: false,
        logGame: false,
        aiDelayShort: 1000,    // Kurze Delays (nach Würfen)
        aiDelayMedium: 1500,   // Mittlere Delays (zwischen Würfen)
        aiDelayLong: 2000      // Lange Delays (vor erstem Wurf)
    };
    let computerVoice, confirmBeep, warpSound, shaker, singleHit, shakeLoop, computerChatter, computerChatterSeq;
    const CATEGORIES = [
        { id: 'ones', name: 'Einser', isUpper: true, value: 1 }, { id: 'twos', name: 'Zweier', isUpper: true, value: 2 }, { id: 'threes', name: 'Dreier', isUpper: true, value: 3 },
        { id: 'fours', name: 'Vierer', isUpper: true, value: 4 }, { id: 'fives', name: 'Fünfer', isUpper: true, value: 5 }, { id: 'sixes', name: 'Sechser', isUpper: true, value: 6 },
        { id: 'upperTotal', name: 'Summe Oben', isTotal: true }, { id: 'bonus', name: 'Bonus (63+)', isTotal: true },
        { id: 'upperGrandTotal', name: 'Gesamt Oben', isTotal: true }, { id: 'threeOfAKind', name: '3er-Pasch', isUpper: false },
        { id: 'fourOfAKind', name: '4er-Pasch', isUpper: false }, { id: 'Full House', name: 'Full House', isUpper: false },
        { id: 'smallStraight', name: 'Kl. Straße', isUpper: false }, { id: 'largeStraight', name: 'Gr. Straße', isUpper: false },
        { id: 'kniffel', name: 'TRIFFEL', isUpper: false }, { id: 'chance', name: 'Chance', isUpper: false },
        { id: 'lowerTotal', name: 'Summe Unten', isTotal: true }, { id: 'grandTotal', name: 'Gesamt', isTotal: true },
    ];
    const TOP_DOWN_ORDER = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes', 'threeOfAKind', 'fourOfAKind', 'Full House', 'smallStraight', 'largeStraight', 'kniffel', 'chance'];
    const STAR_TREK_NAMES = ['Data', 'Spock', 'Worf', 'Picard', 'Riker', 'Geordi', 'Seven of Nine', 'Janeway', 'Sisko'];
    const COLUMN_MULTIPLIERS = { col1: 1, col2: 2, col3: 2, col4: 3 };
    const dieIconSVG = `<svg width="24" height="24" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.15 28.33L50 5L94.85 28.33V71.67L50 95L5.15 71.67V28.33Z" stroke="var(--lcars-tan)" stroke-width="5"/><path d="M5.15 28.33L50 50M94.85 28.33L50 50M5.15 71.67L50 50" stroke="var(--lcars-tan)" stroke-width="3"/></svg>`;
    const lockIconSVG = `<svg class="lock-icon" viewBox="0 0 24 24"><path stroke="var(--lcars-tan)" stroke-width="2" fill="var(--lcars-bg)" d="M12 1.5A5.25 5.25 0 006.75 6.75v3H6a3 3 0 00-3 3v7.5a3 3 0 003 3h12a3 3 0 003-3v-7.5a3 3 0 00-3-3h-.75v-3A5.25 5.25 0 0012 1.5zM8.25 6.75a3.75 3.75 0 017.5 0v3H8.25v-3z"></path></svg>`;
    const AI_PRIORITY = { A_HIGH_VALUE: 0, B_BONUS_SECTION: 1, C_COLUMN1_BUFFER: 2, D_CHANCE: 3, E_STRATEGIC_STRIKE: 4, F_STANDARD_STRIKE: 5, G_REROLL: 6, H_EMERGENCY_STRIKE: 7 };


    // --- INITIALIZATION ---
    function initGame() {
        state = {
            playerName: playerNameInput.value || 'Spieler 1',
            computerName: STAR_TREK_NAMES[Math.floor(Math.random() * STAR_TREK_NAMES.length)],
            aiDifficulty: 'hard',
            currentPlayer: 'player',
            rollsLeft: 3,
            dice: [0, 0, 0, 0, 0],
            firstRollDice: [],
            kept: [false, false, false, false, false],
            gamePhase: 'beforeRoll',
            turn: 1,
            scores: { player: createPlayerScores(), computer: createPlayerScores() },
            hasRolledMoreThanOnce: false,
            lastAiMove: null,
            screenshotCounter: 1,
            gameLog: [],
            settings: { ...globalSettings },
            lastPlayerState: null,
            undoUsedThisTurn: false,
        };
        state.turnId = 1; // Eindeutige ID für jeden Zug, um asynchrone Züge abzubrechen
        gameContainer.classList.remove('hidden');
        buildScoreboard();
        startTurn();
    }

    function createPlayerScores() {
        const scores = {};
        for (let i = 1; i <= 4; i++) {
            scores[`col${i}`] = {};
            CATEGORIES.forEach(cat => { if (!cat.isTotal) scores[`col${i}`][cat.id] = null; });
            scores[`col${i}`].sequentialFieldAttempts = {};
            TOP_DOWN_ORDER.forEach(catId => scores[`col${i}`].sequentialFieldAttempts[catId] = 0);
        }
        return scores;
    }

    // --- AUDIO & BOARDING ---
    function setupAudio() {
        const filter = new Tone.AutoFilter("4n").toDestination().start();
        computerVoice = new Tone.AMSynth({ harmonicity: 1.5, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 } }).connect(filter);
        confirmBeep = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
        warpSound = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.1, decay: 1.5, sustain: 0, release: 0.1 } }).toDestination();
        shaker = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 } }).toDestination();
        shaker.volume.value = -20;
        singleHit = new Tone.MembraneSynth({ octaves: 4, pitchDecay: 0.1, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination();
        singleHit.volume.value = -10;
        shakeLoop = new Tone.Loop(time => { shaker.triggerAttack(time); }, "16n").start(0);
        computerChatter = new Tone.Synth({ oscillator: { type: "sawtooth" }, volume: -25, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
        const notes = ["C4", "D4", "E4", "G4", "A4", null, "E4", null];
        computerChatterSeq = new Tone.Sequence((time, note) => {
            if (note) computerChatter.triggerAttackRelease(note, "32n", time);
        }, notes, "16n").start(0);
    }
    async function playBoardingSequence() {
        setupScreen.style.opacity = 0;
        await new Promise(r => setTimeout(r, 500));
        setupScreen.classList.add('hidden');
        boardingScreen.classList.add('active');
        confirmBeep.triggerAttackRelease("C5", "8n");
        const lines = ["INITIALISIERE WARPKERN...", "SYNCHRONISIERE TRIFFEL-MATRIX...", "KALIBRIERE WAHRSCHEINLICHKEITS-ANTRIEBE...", `WILLKOMMEN AUF DER BRÜCKE, CAPTAIN ${state.playerName.toUpperCase()}`];
        for (const line of lines) {
            const p = document.createElement('p');
            p.className = 'boarding-text';
            p.textContent = line;
            boardingTextContainer.innerHTML = '';
            boardingTextContainer.appendChild(p);
            computerVoice.triggerAttackRelease("C2", "1n");
            await new Promise(r => setTimeout(r, 100));
            p.style.opacity = 1;
            await new Promise(r => setTimeout(r, 1500));
        }
        warpSound.triggerAttack();
        await new Promise(r => setTimeout(r, 500));
        boardingScreen.style.opacity = 0;
        await new Promise(r => setTimeout(r, 500));
        boardingScreen.classList.remove('active');
        initGame();
    }

    // --- UI RENDERING ---
    function createDieFace(value, index) { if (value === 0 || (state.gamePhase === 'rolling' && !state.kept[index])) { return '?'; } let dots = ''; for (let i = 0; i < value; i++) { dots += '<div class="dot"></div>'; } return `<div class="die-face face-${value}">${dots}</div>${lockIconSVG}`; }
    
    function buildScoreboard() {
        scoreboardHeader.innerHTML = `
            <tr class="border-b-2 border-lcars-blue">
                <th class="p-2 text-left">KATEGORIE</th>
                <th colspan="4" class="p-2 player-header" id="player-header-p1">${state.playerName.toUpperCase()}</th>
                <th colspan="4" class="p-2 player-header player-divider" id="player-header-p2">${state.computerName.toUpperCase()}</th>
            </tr>
            <tr class="text-xs text-lcars-tan">
                <th class="p-1"></th>
                <th class="p-1 font-normal">x1</th>
                <th class="p-1 font-normal">x2 O-U</th>
                <th class="p-1 font-normal">x2 U-O</th>
                <th class="p-1 font-normal">x3 Wurf 1</th>
                <th class="p-1 font-normal player-divider">x1</th>
                <th class="p-1 font-normal">x2 O-U</th>
                <th class="p-1 font-normal">x2 U-O</th>
                <th class="p-1 font-normal">x3 Wurf 1</th>
            </tr>`;
        scoreboardBody.innerHTML = '';
        const dividerAfterRows = ['sixes', 'upperGrandTotal', 'chance'];
        CATEGORIES.forEach(cat => {
            const row = document.createElement('tr');
            if (cat.isTotal) row.classList.add('total-row');
            if (dividerAfterRows.includes(cat.id)) {
                row.classList.add('section-divider');
            }

            row.innerHTML += `<td class="category-name">${cat.name}</td>`;
            ['player', 'computer'].forEach(player => {
                for (let i = 1; i <= 4; i++) {
                    let cellClasses = "score-cell border-l";
                    if (player === 'computer' && i === 1) {
                        cellClasses += " player-divider";
                    }
                    row.innerHTML += `<td id="${player}-${cat.id}-col${i}" class="${cellClasses}" data-player="${player}" data-category="${cat.id}" data-column="col${i}"></td>`;
                }
            });
            scoreboardBody.appendChild(row);
        });
    }

    function render() {
        diceElements.forEach((die, index) => {
            die.innerHTML = createDieFace(state.dice[index], index);
            die.classList.toggle('kept', state.kept[index]);
            die.classList.toggle('rolling', state.gamePhase === 'rolling' && !state.kept[index]);
        });
        document.getElementById('player-header-p1').classList.toggle('active-player', state.currentPlayer === 'player');
        document.getElementById('player-header-p2').classList.toggle('active-player', state.currentPlayer === 'computer');
        rollsLeftIcons.innerHTML = Array(state.rollsLeft).fill(dieIconSVG).join('');
        rollButton.disabled = state.rollsLeft === 0 || state.gamePhase === 'rolling';
        undoButton.style.display = state.lastPlayerState && !state.undoUsedThisTurn ? 'flex' : 'none';
        updateAllScoresUI();
        highlightAvailableCells();
    }
    
    function updateAllScoresUI() {
        ['player', 'computer'].forEach(player => {
            for (let i = 1; i <= 4; i++) {
                const col = `col${i}`;
                let upperTotal = 0;
                let lowerTotal = 0;

                TOP_DOWN_ORDER.forEach((catId, index) => {
                    const score = state.scores[player][col][catId];
                    const cell = document.getElementById(`${player}-${catId}-${col}`);
                    if (cell) {
                        cell.classList.remove('filled', 'struck', 'available', 'strikeable', 'potential-score', 'last-ai-move');
                        cell.innerHTML = ''; 

                        if (score !== null) {
                            if (score === -1) {
                                cell.innerHTML = '✗'; // Verwende ein X-Symbol statt "X"
                                cell.classList.add('filled', 'struck');
                            } else {
                                cell.textContent = score;
                                cell.classList.add('filled');
                            }
                        }
                    }
                    // Nur positive Scores zur Summe hinzufügen (gestrichene Felder nicht)
                    if (score > 0) {
                        if (index < 6) { upperTotal += score; } 
                        else { lowerTotal += score; }
                    }
                });

                const bonus = upperTotal >= 63 ? 35 : 0;
                const upperGrandTotal = upperTotal + bonus;
                
                document.getElementById(`${player}-upperTotal-${col}`).textContent = upperTotal;
                document.getElementById(`${player}-bonus-${col}`).textContent = bonus;
                document.getElementById(`${player}-upperGrandTotal-${col}`).textContent = upperGrandTotal;
                document.getElementById(`${player}-lowerTotal-${col}`).textContent = lowerTotal;
                document.getElementById(`${player}-grandTotal-${col}`).textContent = upperGrandTotal + lowerTotal;
            }
        });
        if (state.lastAiMove) {
            const lastCell = document.getElementById(`computer-${state.lastAiMove.category}-${state.lastAiMove.column}`);
            if (lastCell) lastCell.classList.add('last-ai-move');
        }
    }

    function getFinalScoresHTML() {
        let playerFinalTotal = 0;
        let computerFinalTotal = 0;
        let playerTotals = [];
        let computerTotals = [];

        const calculateColumnGrandTotal = (player, col) => {
            let upperTotal = 0;
            let lowerTotal = 0;
            TOP_DOWN_ORDER.forEach((catId, index) => {
                const score = state.scores[player][col][catId];
                if (score > 0) {
                    if (index < 6) { upperTotal += score; } 
                    else { lowerTotal += score; }
                }
            });
            const bonus = upperTotal >= 63 ? 35 : 0;
            return upperTotal + bonus + lowerTotal;
        };

        for (let i = 1; i <= 4; i++) {
            const col = `col${i}`;
            const multiplier = COLUMN_MULTIPLIERS[col];
            const playerColTotal = calculateColumnGrandTotal('player', col);
            playerTotals.push(playerColTotal * multiplier);
            playerFinalTotal += playerColTotal * multiplier;
            const computerColTotal = calculateColumnGrandTotal('computer', col);
            computerTotals.push(computerColTotal * multiplier);
            computerFinalTotal += computerColTotal * multiplier;
        }

        return `
            <table class="w-full text-center">
                <thead>
                    <tr>
                        <th></th>
                        <th class="p-2">${state.playerName.toUpperCase()}</th>
                        <th class="p-2">${state.computerName.toUpperCase()}</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td class="text-left p-2">Spalte 1 (x1)</td><td>${playerTotals[0]}</td><td>${computerTotals[0]}</td></tr>
                    <tr><td class="text-left p-2">Spalte 2 (x2)</td><td>${playerTotals[1]}</td><td>${computerTotals[1]}</td></tr>
                    <tr><td class="text-left p-2">Spalte 3 (x2)</td><td>${playerTotals[2]}</td><td>${computerTotals[2]}</td></tr>
                    <tr><td class="text-left p-2">Spalte 4 (x3)</td><td>${playerTotals[3]}</td><td>${computerTotals[3]}</td></tr>
                    <tr class="text-lcars-orange text-2xl section-divider"><td class="text-left p-2">GESAMT</td><td>${playerFinalTotal}</td><td>${computerFinalTotal}</td></tr>
                </tbody>
            </table>
        `;
    }

    function updateScoreModal() {
        scoreModalContent.innerHTML = getFinalScoresHTML();
    }
    
    function highlightAvailableCells() {
        if (state.currentPlayer !== 'player' || state.gamePhase === 'beforeRoll') return;

        const isFinalScoring = state.gamePhase === 'scoring';

        const processColumn = (colNum, diceToUse, allowScoring) => {
            if (!diceToUse || diceToUse.length !== 5) return;

            const col = `col${colNum}`;
            const order = (colNum === 3) ? [...TOP_DOWN_ORDER].reverse() : TOP_DOWN_ORDER;

            for (const catId of order) {
                const cell = document.getElementById(`player-${catId}-${col}`);
                if (state.scores.player[col][catId] !== null) continue;

                let isSequentiallyAvailable = (colNum === 1 || colNum === 4) ||
                    (colNum === 2 && (TOP_DOWN_ORDER.indexOf(catId) === 0 || state.scores.player[col][TOP_DOWN_ORDER[TOP_DOWN_ORDER.indexOf(catId) - 1]] !== null)) ||
                    (colNum === 3 && (order.indexOf(catId) === 0 || state.scores.player[col][order[order.indexOf(catId) - 1]] !== null));

                if (isSequentiallyAvailable) {
                    const score = calculateScore(catId, diceToUse);
                    if (allowScoring) {
                         if (isFinalScoring) {
                            if (score > 0) {
                                cell.innerHTML = score;
                                cell.classList.add('available');
                            } else {
                                cell.innerHTML = '✗'; // Verwende das gleiche Symbol
                                cell.classList.add('available', 'strikeable');
                            }
                        } else { // Preview mode
                            if (score > 0) {
                                cell.classList.add('available', 'potential-score');
                            }
                        }
                    } else if (isFinalScoring) { // Only allow striking
                        cell.innerHTML = '✗'; // Verwende das gleiche Symbol
                        cell.classList.add('available', 'strikeable');
                    }
                }
                if ((colNum === 2 || colNum === 3) && isSequentiallyAvailable) break; 
            }
        };

        [1, 2, 3].forEach(colNum => processColumn(colNum, state.dice, true));
        processColumn(4, state.firstRollDice, !state.hasRolledMoreThanOnce);
    }

    // --- GAME LOGIC ---
    function startTurn() {
        if (state.turn > TOP_DOWN_ORDER.length * 4) {
            gameOver();
            return;
        }

        if (state.lastAiMove) {
            const lastCell = document.getElementById(`computer-${state.lastAiMove.category}-${state.lastAiMove.column}`);
            if (lastCell) lastCell.classList.remove('last-ai-move');
            state.lastAiMove = null;
        }
        state.rollsLeft = 3;
        state.kept = [false, false, false, false, false];
        state.dice = [0,0,0,0,0];
        state.firstRollDice = [];
        state.hasRolledMoreThanOnce = false;
        state.gamePhase = 'beforeRoll';
        state.undoUsedThisTurn = false;
        if (state.currentPlayer === 'computer') computerTurn();
        else render();
    }
    async function animateAndRollDice(diceToRollCount) {
        const rollDuration = 1200;
        if (state.settings.sound && diceToRollCount > 1) {Tone.Transport.start();shakeLoop.start(0);} 
        else if (state.settings.sound && diceToRollCount === 1) {singleHit.triggerAttackRelease("C2", "8n");}
        state.gamePhase = 'rolling';
        
        diceElements.forEach((die, index) => {
            if (!state.kept[index]) {
                die.style.animationDelay = `${Math.random() * 0.2}s`;
            }
        });
        render();
        
        await new Promise(resolve => setTimeout(resolve, rollDuration));
        
        if (state.settings.sound && diceToRollCount > 1) {shakeLoop.stop();Tone.Transport.stop();}
        
        diceElements.forEach((die, index) => {
            if (!state.kept[index]) {
                state.dice[index] = Math.floor(Math.random() * 6) + 1;
            }
            die.style.animationDelay = '';
        });
    }
    
    async function rollDice() {
        if (state.rollsLeft <= 0 || state.currentPlayer !== 'player' || state.gamePhase === 'rolling') return;
        const diceToRollCount = state.kept.filter(k => !k).length;
        if (diceToRollCount === 0 && state.rollsLeft > 0) {
            state.rollsLeft = 0;
            state.gamePhase = 'scoring';
            render();
            return;
        }
        if (state.rollsLeft < 3) {
            state.hasRolledMoreThanOnce = true;
        }
        state.rollsLeft--;
        await animateAndRollDice(diceToRollCount);

        // --- LOGGING: Spieler-Wurf ---
        if (state.settings.logGame) {
            state.gameLog.push({
                type: 'roll',
                player: 'player',
                dice: state.dice.slice(),
                kept: state.kept.slice(),
                turn: state.turn,
                rollsLeft: state.rollsLeft,
                timestamp: Date.now()
            });
        }

        if (state.rollsLeft === 2) {
            state.firstRollDice = [...state.dice];
        }
        state.gamePhase = state.rollsLeft === 0 ? 'scoring' : 'afterRoll';
        render();
        if (state.settings.screenshots) {
            await takeScreenshot(`triffel_zug_${state.turn}_wurf_${3 - state.rollsLeft}.png`);
        }
    }

    async function selectScore(category, column) {
        state.lastPlayerState = JSON.parse(JSON.stringify(state));

        const cell = document.getElementById(`player-${category}-${column}`);
        const isStrike = cell.classList.contains('strikeable');
        const diceToUse = (column === 'col4' && !state.hasRolledMoreThanOnce) ? state.firstRollDice : state.dice;
        const score = isStrike ? -1 : calculateScore(category, diceToUse);
        
        if (score === 0 && !isStrike) return;

        state.scores.player[column][category] = score;
        if (category === 'kniffel' && score === 50) {
            triggerConfetti(cell);
        }

        // --- LOGGING: Spieler-Eintrag/Streichen ---
        if (state.settings.logGame) {
            state.gameLog.push({
                type: isStrike ? 'strike' : 'entry',
                player: 'player',
                category,
                column,
                score,
                dice: diceToUse.slice(),
                turn: state.turn,
                rollsLeft: state.rollsLeft,
                timestamp: Date.now()
            });
        }

        if (state.settings.screenshots) {
            await takeScreenshot(`triffel_zug_${state.turn}_eintrag_${category}.png`);
        }
        endTurn();
    }
    function endTurn() {
        if (state.currentPlayer === 'computer') {
            state.turn++;
        }
        state.currentPlayer = state.currentPlayer === 'player' ? 'computer' : 'player';
        startTurn();
    }
    async function gameOver() {
        state.gamePhase = 'gameOver';
        missionAnalysisModal.classList.remove('hidden');
        const lines = ["MISSIONSDATEN WERDEN ANALYSIERT...", "BERECHNE EFFIZIENZ-MATRIX...", "WAHRSCHEINLICHKEITS-PROTOKOLLE WERDEN ABGESCHLOSSEN...", "FINALE AUSWERTUNG VERFÜGBAR."];
        missionAnalysisTextContainer.innerHTML = '';
        for (const line of lines) {
            const p = document.createElement('p');
            p.className = 'boarding-text';
            p.textContent = line;
            missionAnalysisTextContainer.appendChild(p);
            if (state.settings.sound) computerVoice.triggerAttackRelease("C2", "8n");
            await new Promise(r => setTimeout(r, 100));
            p.style.opacity = 1;
            await new Promise(r => setTimeout(r, 1000));
        }

        await new Promise(r => setTimeout(r, 500));
        missionAnalysisModal.classList.add('hidden');

        finalScoresTable.innerHTML = getFinalScoresHTML();
        let playerScore = 0;
        let computerScore = 0;
        for(let i=1; i<=4; i++){
            playerScore += (parseInt(document.getElementById(`player-grandTotal-col${i}`).textContent) || 0) * COLUMN_MULTIPLIERS[`col${i}`];
            computerScore += (parseInt(document.getElementById(`computer-grandTotal-col${i}`).textContent) || 0) * COLUMN_MULTIPLIERS[`col${i}`];
        }

        if (playerScore > computerScore) {
            winnerInfo.textContent = `${state.playerName.toUpperCase()} HAT GEWONNEN!`;
        } else if (computerScore > playerScore) {
            winnerInfo.textContent = `${state.computerName.toUpperCase()} HAT GEWONNEN!`;
        } else {
            winnerInfo.textContent = "UNENTSCHIEDEN!";
        }
        gameOverModal.classList.remove('hidden');

        // Protokoll-Download anbieten, falls aktiviert
        if (state.settings.logGame && state.gameLog && state.gameLog.length > 0) {
            const logStr = JSON.stringify(state.gameLog, null, 2);
            const blob = new Blob([logStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            // Download-Link erzeugen oder aktualisieren
            let logDownload = document.getElementById('log-download-link');
            if (!logDownload) {
                logDownload = document.createElement('a');
                logDownload.id = 'log-download-link';
                logDownload.className = 'lcars-button mt-4';
                logDownload.textContent = 'Spielprotokoll herunterladen';
                logDownload.style.display = 'inline-block';
                gameOverModal.querySelector('.modal-content').appendChild(logDownload);
            }
            logDownload.href = url;
            logDownload.download = `triffel_log_${Date.now()}.json`;
            logDownload.style.display = 'inline-block';
        } else {
            // Falls vorhanden, Link ausblenden
            const logDownload = document.getElementById('log-download-link');
            if (logDownload) logDownload.style.display = 'none';
        }

        // Nach dem finalScoresTable.innerHTML = getFinalScoresHTML(); und vor gameOverModal.classList.remove('hidden');
        const buttonRow = document.createElement('div');
        buttonRow.className = 'flex flex-row justify-between items-center gap-4 mt-6';

        // Download-Button nur anzeigen, wenn aktiviert und Daten vorhanden
        let logDownload = document.getElementById('log-download-link');
        if (logDownload) logDownload.remove();

        if (state.settings.logGame && state.gameLog && state.gameLog.length > 0) {
            // CSV erzeugen
            const csvHeader = Object.keys(state.gameLog[0]).join(';');
            const csvRows = state.gameLog.map(entry =>
                Object.values(entry).map(v =>
                    typeof v === 'string' && v.includes(';') ? `"${v.replace(/"/g, '""')}"` : v
                ).join(';')
            );
            const csvContent = [csvHeader, ...csvRows].join('\r\n');
            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = URL.createObjectURL(blob);

            logDownload = document.createElement('a');
            logDownload.id = 'log-download-link';
            logDownload.className = 'lcars-button';
            logDownload.textContent = 'Download Protokoll';
            logDownload.href = url;
            logDownload.download = `triffel_log_${Date.now()}.csv`;
            buttonRow.appendChild(logDownload);
        }

        // "Neue Mission"-Button nach rechts
        newGameButton.classList.add('ml-auto');
        buttonRow.appendChild(newGameButton);

        // Button-Row einfügen (vorher ggf. entfernen)
        const modalContent = gameOverModal.querySelector('.modal-content');
        const oldButtonRow = modalContent.querySelector('.flex.flex-row');
        if (oldButtonRow) oldButtonRow.remove();
        modalContent.appendChild(buttonRow);
    }
    function calculateScore(category, dice) {const counts = Array(6).fill(0);let sum = 0;dice.forEach(d => { counts[d - 1]++; sum += d; });switch (category) {case 'ones': return counts[0] * 1;case 'twos': return counts[1] * 2;case 'threes': return counts[2] * 3;case 'fours': return counts[3] * 4;case 'fives': return counts[4] * 5;case 'sixes': return counts[5] * 6;case 'threeOfAKind': return counts.some(c => c >= 3) ? sum : 0;case 'fourOfAKind': return counts.some(c => c >= 4) ? sum : 0;case 'Full House': return counts.includes(3) && counts.includes(2) ? 25 : 0;case 'kniffel': return counts.some(c => c >= 5) ? 50 : 0;case 'chance': return sum;case 'smallStraight': return /1234|2345|3456/.test([...new Set(dice)].sort().join('')) ? 30 : 0;case 'largeStraight': return /12345|23456/.test([...new Set(dice)].sort().join('')) ? 40 : 0;default: return 0;}}
    function triggerConfetti(element) {if(!element) return; const rect = element.getBoundingClientRect();const colors = ['#FF9900', '#6699FF', '#CC99FF', '#FFCC99'];for (let i = 0; i < 50; i++) {const confetti = document.createElement('div');confetti.className = 'confetti';document.body.appendChild(confetti);confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];confetti.style.left = rect.left + rect.width / 2 + 'px';confetti.style.top = rect.top + rect.height / 2 + 'px';const angle = Math.random() * Math.PI * 2;const velocity = Math.random() * 50 + 50;const x = Math.cos(angle) * velocity;const y = Math.sin(angle) * velocity - 50;confetti.style.transition = 'transform 1s ease-out, opacity 1s ease-out';confetti.style.opacity = 1;setTimeout(() => {confetti.style.transform = `translate(${x}px, ${y + 100}px) rotate(360deg)`;confetti.style.opacity = 0;}, 10);setTimeout(() => { confetti.remove(); }, 1010);}}
    
    // --- NEW AI LOGIC BASED ON PSEUDOCODE ---

    class KniffelAI {
        constructor(scorecard = {}) {
            this.scorecard = scorecard;
            this.SCORE_CATEGORIES = [
                'ones', 'twos', 'threes', 'fours', 'fives', 'sixes',
                'threeOfAKind', 'fourOfAKind', 'Full House', 'smallStraight',
                'largeStraight', 'kniffel', 'chance'
            ];
            this.MULTIPLIERS = { 'col1': 1, 'col2': 2, 'col3': 2, 'col4': 3 };
            this.BONUS_THRESHOLD = 63;
        }

        _calculateBasePoints(dice, category) {
            const counts = dice.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
            const diceSum = dice.reduce((sum, d) => sum + d, 0);

            const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
            const upperIndex = upperCategories.indexOf(category);
            
            if (upperIndex !== -1) {
                const value = upperIndex + 1;
                return (counts[value] || 0) * value;
            } else if (['threeOfAKind', 'fourOfAKind', 'chance'].includes(category)) {
                return diceSum;
            } else if (category === 'Full House' && Object.values(counts).includes(3) && Object.values(counts).includes(2)) {
                return 25;
            } else if (category === 'smallStraight' && this._isSmallStraight(dice)) {
                return 30;
            } else if (category === 'largeStraight' && this._isLargeStraight(dice)) {
                return 40;
            } else if (category === 'kniffel' && Object.values(counts).includes(5)) {
                return 50;
            }
            
            return 0;
        }

        _isSmallStraight(dice) {
            const uniqueDice = [...new Set(dice)];
            return [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]].some(s => s.every(d => uniqueDice.includes(d)));
        }

        _isLargeStraight(dice) {
            return [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6]].some(s => s.every(d => dice.includes(d)));
        }

        _isFieldAvailable(category, column) {
            // Prüfe ob das Feld bereits belegt ist
            if (this.scorecard[column] && this.scorecard[column][category] !== undefined && this.scorecard[column][category] !== null) {
                return false;
            }

            // Spalte 1 und 4: Alle Felder frei wählbar
            if (column === 'col1' || column === 'col4') {
                return true;
            }

            // Spalte 2: Strikt von oben nach unten
            if (column === 'col2') {
                const categoryIndex = this.SCORE_CATEGORIES.indexOf(category);
                // Prüfe ob alle vorherigen Felder bereits ausgefüllt sind
                for (let i = 0; i < categoryIndex; i++) {
                    const prevCategory = this.SCORE_CATEGORIES[i];
                    if (!this.scorecard[column] || this.scorecard[column][prevCategory] === null || this.scorecard[column][prevCategory] === undefined) {
                        return false; // Vorheriges Feld ist noch nicht ausgefüllt
                    }
                }
                return true;
            }

            // Spalte 3: Strikt von unten nach oben
            if (column === 'col3') {
                const categoryIndex = this.SCORE_CATEGORIES.indexOf(category);
                // Prüfe ob alle nachfolgenden Felder bereits ausgefüllt sind
                for (let i = categoryIndex + 1; i < this.SCORE_CATEGORIES.length; i++) {
                    const nextCategory = this.SCORE_CATEGORIES[i];
                    if (!this.scorecard[column] || this.scorecard[column][nextCategory] === null || this.scorecard[column][nextCategory] === undefined) {
                        return false; // Nachfolgendes Feld ist noch nicht ausgefüllt
                    }
                }
                return true;
            }

            return false;
        }

        _calculateActionScore(dice, category, column, rollNumber) {
            // Prüfe sequentielle Verfügbarkeit
            if (!this._isFieldAvailable(category, column)) {
                return -Infinity;
            }

            const basePoints = this._calculateBasePoints(dice, category);
            if (basePoints === 0) return -Infinity;
            
            const columnMultiplier = this.MULTIPLIERS[column];
            let bonusSecurityFactor = 1.0;
            let urgencyFactor = 1.0;

            // Bonus-Sicherheits-Faktor
            const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
            if (['col2', 'col3', 'col4'].includes(column) && upperCategories.includes(category)) {
                const upperScore = Object.entries(this.scorecard[column] || {})
                                        .filter(([c, _]) => upperCategories.includes(c))
                                        .reduce((sum, [_, points]) => sum + (points > 0 ? points : 0), 0);
                const potentialScore = upperScore + basePoints;
                
                if (potentialScore >= this.BONUS_THRESHOLD) {
                    bonusSecurityFactor = 1.8;
                } else if (basePoints < 12) {
                    bonusSecurityFactor = 0.7;
                } else {
                    bonusSecurityFactor = 1.0 + (potentialScore / this.BONUS_THRESHOLD) * 0.5;
                }
            }

            // Feld-Dringlichkeits-Faktor für sequentielle Spalten
            if (column === 'col2') {
                // Nächstes zu füllendes Feld von oben
                const nextFieldIndex = this.SCORE_CATEGORIES.findIndex(f => 
                    !this.scorecard[column] || this.scorecard[column][f] === null || this.scorecard[column][f] === undefined
                );
                if (this.SCORE_CATEGORIES.indexOf(category) === nextFieldIndex) {
                    urgencyFactor = 1.5;
                }
            } else if (column === 'col3') {
                // Nächstes zu füllendes Feld von unten
                const reversedCategories = [...this.SCORE_CATEGORIES].reverse();
                const nextFieldIndex = reversedCategories.findIndex(f => 
                    !this.scorecard[column] || this.scorecard[column][f] === null || this.scorecard[column][f] === undefined
                );
                if (reversedCategories.indexOf(category) === nextFieldIndex) {
                    urgencyFactor = 1.5;
                }
            }
            
            let actionScore = (basePoints * columnMultiplier) * bonusSecurityFactor * urgencyFactor;

            // Hierarchical boosts
            if (column === 'col4' && rollNumber === 1 && ['kniffel', 'largeStraight', 'Full House'].includes(category)) {
                actionScore *= 2.0;
            }
            if (['col2', 'col3'].includes(column) && ['kniffel', 'largeStraight', 'Full House', 'fourOfAKind'].includes(category)) {
                actionScore *= 1.5;
            }

            return actionScore;
        }

        getBestAction(dice, rollNumber) {
            let bestAction = { score: -Infinity, action: 'Keine Aktion möglich', details: null };

            // Step 1: Evaluate all entry options
            for (const column of Object.keys(this.MULTIPLIERS)) {
                for (const category of this.SCORE_CATEGORIES) {
                    const score = this._calculateActionScore(dice, category, column, rollNumber);
                    if (score > bestAction.score) {
                        bestAction.score = score;
                        bestAction.action = 'Eintragen';
                        bestAction.details = { category, column };
                    }
                }
            }

            // Step 2: Evaluate the option to re-roll
            const rerollScore = 150;
            if (rollNumber < 3 && bestAction.score < rerollScore) {
                bestAction.score = rerollScore;
                bestAction.action = 'Weiterwürfeln';
                bestAction.details = this._determineDiceToKeep(dice);
            }

            // Step 3: Evaluate the option to scratch
            if (rollNumber === 3 && (bestAction.action === 'Keine Aktion möglich' || bestAction.score === -Infinity)) {
                const scratchDetails = this._determineFieldToScratch();
                if (scratchDetails) {
                    bestAction.score = 1;
                    bestAction.action = 'Streichen';
                    bestAction.details = scratchDetails;
                }
            }
            
            return bestAction;
        }

        _determineDiceToKeep(dice) {
            const counts = dice.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
            
            // Bestimme welche Würfel behalten werden sollen
            let keptIndices = [];
            
            if (Object.values(counts).includes(5)) {
                keptIndices = [true, true, true, true, true]; // alle Würfel
            } else if (Object.values(counts).includes(4)) {
                const targetValue = Object.keys(counts).find(key => counts[key] === 4);
                keptIndices = dice.map(d => d == targetValue);
            } else if (this._isLargeStraight(dice)) {
                const straight = [1,2,3,4,5].every(d => dice.includes(d)) ? [1,2,3,4,5] : [2,3,4,5,6];
                keptIndices = dice.map(d => straight.includes(d));
            } else if (Object.values(counts).includes(3) && Object.values(counts).includes(2)) {
                keptIndices = [true, true, true, true, true]; // Full House
            } else if (Object.values(counts).includes(3)) {
                const targetValue = Object.keys(counts).find(key => counts[key] === 3);
                keptIndices = dice.map(d => d == targetValue);
            } else {
                // Behalte die höchsten Würfel
                keptIndices = dice.map(d => d >= 5);
            }
            
            return keptIndices;
        }

        _determineFieldToScratch() {
            // Prioritätsliste für das Streichen - bevorzuge verfügbare Felder
            const priorities = [
                { category: 'ones', column: 'col1' },
                { category: 'twos', column: 'col1' },
                { category: 'kniffel', column: 'col1' },
                { category: 'chance', column: 'col1' }
            ];
            
            for (const field of priorities) {
                if (this._isFieldAvailable(field.category, field.column)) {
                    return field;
                }
            }
            
            // Falls alle Prioritätsfelder nicht verfügbar sind, finde das erste verfügbare Feld
            for (const column of Object.keys(this.MULTIPLIERS)) {
                for (const category of this.SCORE_CATEGORIES) {
                    if (this._isFieldAvailable(category, column)) {
                        return { category, column };
                    }
                }
            }
            
            return null;
        }
    }

    async function executeComputerMoveNew(move, turnId = null) {
        // Überprüfe ob dieser Zug noch aktuell ist
        if (turnId !== null && turnId !== state.turnId - 1) return;
        
        if (state.settings.sound) {
            computerChatterSeq.stop();
            Tone.Transport.stop();
            confirmBeep.triggerAttackRelease("A3", "16n");
        }
        
        const score = move.type === 'STREICHEN' ? -1 : calculateScore(move.category, state.dice);
        state.scores.computer[move.column][move.category] = score;
        state.lastAiMove = { category: move.category, column: move.column };

        // --- LOGGING: KI-Eintrag/Streichen ---
        if (state.settings.logGame) {
            state.gameLog.push({
                type: move.type === 'STREICHEN' ? 'strike' : 'entry',
                player: 'computer',
                category: move.category,
                column: move.column,
                score,
                dice: state.dice.slice(),
                turn: state.turn,
                rollsLeft: state.rollsLeft,
                timestamp: Date.now()
            });
        }

        const chosenCell = document.getElementById(`computer-${move.category}-${move.column}`);
        if(chosenCell) {
            chosenCell.style.transition = 'background-color 0.2s';
            chosenCell.style.backgroundColor = 'var(--lcars-orange)';
            await new Promise(res => setTimeout(res, 1200));
            chosenCell.style.backgroundColor = '';
        }
        endTurn();
    }

    // --- UTILITY FUNCTIONS ---
    async function takeScreenshot(filename) {
        try {
            const canvas = await html2canvas(document.body, {
                backgroundColor: '#000000',
                width: window.innerWidth,
                height: window.innerHeight
            });
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        } catch (error) {
            console.error('Screenshot failed:', error);
        }
    }

    // Add slider event listeners
    const delayShortSlider = document.getElementById('delay-short');
    const delayMediumSlider = document.getElementById('delay-medium');
    const delayLongSlider = document.getElementById('delay-long');
    const delayShortValue = document.getElementById('delay-short-value');
    const delayMediumValue = document.getElementById('delay-medium-value');
    const delayLongValue = document.getElementById('delay-long-value');

    // Initialize slider values
    delayShortSlider.value = globalSettings.aiDelayShort;
    delayMediumSlider.value = globalSettings.aiDelayMedium;
    delayLongSlider.value = globalSettings.aiDelayLong;
    delayShortValue.textContent = (globalSettings.aiDelayShort / 1000).toFixed(1) + 's';
    delayMediumValue.textContent = (globalSettings.aiDelayMedium / 1000).toFixed(1) + 's';
    delayLongValue.textContent = (globalSettings.aiDelayLong / 1000).toFixed(1) + 's';

    delayShortSlider.addEventListener('input', (e) => {
        globalSettings.aiDelayShort = parseInt(e.target.value);
        if(state && state.settings) state.settings.aiDelayShort = globalSettings.aiDelayShort;
        delayShortValue.textContent = (globalSettings.aiDelayShort / 1000).toFixed(1) + 's';
    });

    delayMediumSlider.addEventListener('input', (e) => {
        globalSettings.aiDelayMedium = parseInt(e.target.value);
        if(state && state.settings) state.settings.aiDelayMedium = globalSettings.aiDelayMedium;
        delayMediumValue.textContent = (globalSettings.aiDelayMedium / 1000).toFixed(1) + 's';
    });

    delayLongSlider.addEventListener('input', (e) => {
        globalSettings.aiDelayLong = parseInt(e.target.value);
        if(state && state.settings) state.settings.aiDelayLong = globalSettings.aiDelayLong;
        delayLongValue.textContent = (globalSettings.aiDelayLong / 1000).toFixed(1) + 's';
    });

    // --- EVENT LISTENERS ---
    startGameButton.addEventListener('click', () => {
        console.log('Start game button clicked'); // Debug
        state.playerName = playerNameInput.value || 'Spieler 1';
        Tone.start().then(setupAudio).then(playBoardingSequence);
    });
    rollButton.addEventListener('click', rollDice);
    helpButton.addEventListener('click', () => helpModal.classList.remove('hidden'));
    closeHelpButton.addEventListener('click', () => helpModal.classList.add('hidden'));
    showScoreButton.addEventListener('click', () => {
        updateScoreModal();
        scoreModal.classList.remove('hidden');
    });
    closeScoreButton.addEventListener('click', () => scoreModal.classList.add('hidden'));
    settingsButton.addEventListener('click', () => {
        console.log('Settings button clicked'); // Debug
        settingsModal.classList.remove('hidden');
    });
    settingsButtonSetup.addEventListener('click', () => {
        console.log('Settings button setup clicked'); // Debug
        settingsModal.classList.remove('hidden');
    });
    closeSettingsButton.addEventListener('click', () => settingsModal.classList.add('hidden'));
    soundToggle.addEventListener('change', (e) => {
        globalSettings.sound = e.target.checked;
        if(state && state.settings) state.settings.sound = globalSettings.sound;
        Tone.Master.mute = !globalSettings.sound;
    });
    screenshotToggle.addEventListener('change', (e) => {
        globalSettings.screenshots = e.target.checked;
        if(state && state.settings) state.settings.screenshots = globalSettings.screenshots;
    });
    logToggle.addEventListener('change', (e) => {
        globalSettings.logGame = e.target.checked;
        if(state && state.settings) state.settings.logGame = globalSettings.logGame;
    });
    diceElements.forEach(die => { die.addEventListener('click', () => toggleKeep(parseInt(die.dataset.index))); });
    scoreboardBody.addEventListener('click', (e) => {
        const cell = e.target.closest('.score-cell');
        if (!cell || !cell.classList.contains('available')) return;
        const { player, category, column } = cell.dataset;
        if (player !== 'player') return;
        selectScore(category, column);
    });
    newGameButton.addEventListener('click', () => {
        gameOverModal.classList.add('hidden');
        boardingTextContainer.innerHTML = '';
        setupScreen.style.opacity = 1;
        setupScreen.classList.remove('hidden');
        gameContainer.classList.add('hidden'); // Spiel-Container verstecken
    });
    undoButton.addEventListener('click', () => {
        undoModal.classList.remove('hidden');
    });

    undoYesButton.addEventListener('click', () => {
        if (state.lastPlayerState && !state.undoUsedThisTurn) {
            state = JSON.parse(JSON.stringify(state.lastPlayerState));
            state.undoUsedThisTurn = true;
            render();
        }
        undoModal.classList.add('hidden');
    });

    undoNoButton.addEventListener('click', () => {
        undoModal.classList.add('hidden');
    });

    function toggleKeep(index) {
        if (state.currentPlayer !== 'player' || state.rollsLeft === 0 || state.gamePhase === 'scoring') return;
        
        // Verhindere Selektion von ungewürfelten Würfeln
        if (state.dice[index] === 0) return;
        
        // Verhindere Selektion während des Rollens
        if (state.gamePhase === 'rolling') return;
        
        state.kept[index] = !state.kept[index];
        render();
    }

    // Hilfsfunktion für Fallback-Streichen
    function findAvailableFieldToStrike() {
        const priorities = [
            { category: 'ones', column: 'col1' },
            { category: 'twos', column: 'col1' },
            { category: 'kniffel', column: 'col1' },
            { category: 'chance', column: 'col1' }
        ];
        
        for (const field of priorities) {
            if (state.scores.computer[field.column][field.category] === null) {
                return field;
            }
        }
        
        // Falls alle Prioritätsfelder belegt sind, finde das erste freie Feld
        for (let i = 1; i <= 4; i++) {
            const col = `col${i}`;
            for (const catId of TOP_DOWN_ORDER) {
                if (state.scores.computer[col][catId] === null) {
                    return { category: catId, column: col };
                }
            }
        }
        
        return null;
    }

    // --- REPLACE EXISTING COMPUTER TURN WITH NEW AI ---
    async function computerTurn() {
        const turnId = state.turnId++; // Eindeutige ID für diesen Zug
        
        // Initialisiere KI mit aktuellem Scorecard
        const kiPlayer = new KniffelAI(state.scores.computer);
        
        let rollsRemaining = 3;
        let currentDice = [];
        let firstRollDice = [];

        state.rollsLeft = rollsRemaining;
        state.dice = [0,0,0,0,0];
        state.kept = [false,false,false,false,false];
        state.hasRolledMoreThanOnce = false;
        render();
        
        // Überprüfe ob dieser Zug noch aktuell ist
        if (turnId !== state.turnId - 1) return;
        
        // Warte bevor erster Wurf
        await new Promise(res => setTimeout(res, state.settings.aiDelayLong));
        
        // Überprüfe nochmal ob dieser Zug noch aktuell ist
        if (turnId !== state.turnId - 1) return;
        
        // ERSTER WURF - animiere und setze dann die Werte
        await animateAndRollDice(5);
        
        // WICHTIG: Würfel sind jetzt aufgedeckt, gamePhase auf 'afterRoll' setzen
        state.gamePhase = 'afterRoll';
        render();
        
        // Speichere die Würfelwerte NACH dem Aufdecken
        currentDice = [...state.dice];
        firstRollDice = [...state.dice]; // ERSTWURF-WERTE HIER FESTHALTEN!
        state.firstRollDice = [...state.dice]; // Auch im state speichern
        rollsRemaining--;
        state.rollsLeft = rollsRemaining;

        // --- LOGGING: KI-Wurf (erster Wurf) ---
        if (state.settings.logGame) {
            state.gameLog.push({
                type: 'roll',
                player: 'computer',
                dice: state.dice.slice(),
                kept: state.kept.slice(),
                turn: state.turn,
                rollsLeft: state.rollsLeft,
                timestamp: Date.now()
            });
        }

        // WICHTIG: Zeige Würfelwerte für längere Zeit, bevor KI entscheidet
        await new Promise(r => setTimeout(r, state.settings.aiDelayLong));

        // Schleife für weitere Würfe oder Entscheidungen
        while (rollsRemaining > 0) {
            // Überprüfe ob dieser Zug noch aktuell ist
            if (turnId !== state.turnId - 1) return;
            
            // Aktualisiere KI-Scorecard
            kiPlayer.scorecard = state.scores.computer;
            
            // WICHTIG: Für Spalte 4 immer die Erstwurfwerte verwenden!
            const rollNumber = 4 - rollsRemaining; // 1, 2, oder 3
            
            const decision = kiPlayer.getBestAction(currentDice, rollNumber);

            if (decision.action === 'Eintragen') {
                // SPEZIELLE BEHANDLUNG FÜR SPALTE 4
                if (decision.details.column === 'col4') {
                    // Für Spalte 4 nur Erstwurf erlaubt, aber nach 2+ Würfen sperren
                    if (state.hasRolledMoreThanOnce) {
                        console.log('KI: Spalte 4 nach mehrfachem Würfeln gesperrt');
                        // Suche alternative Eintragung
                        let alternativeFound = false;
                        for (const column of ['col1', 'col2', 'col3']) {
                            for (const category of kiPlayer.SCORE_CATEGORIES) {
                                if (kiPlayer._isFieldAvailable(category, column)) {
                                    const altScore = kiPlayer._calculateActionScore(currentDice, category, column, rollNumber);
                                    if (altScore > -Infinity) {
                                        await executeComputerMoveNew({
                                            type: 'EINTRAGEN',
                                            category: category,
                                            column: column
                                        }, turnId);
                                        alternativeFound = true;
                                        return;
                                    }
                                }
                            }
                        }
                        if (!alternativeFound) {
                            // Fallback: Streichen
                            const fallbackField = findAvailableFieldToStrike();
                            if (fallbackField) {
                                await executeComputerMoveNew({
                                    type: 'STREICHEN',
                                    category: fallbackField.category,
                                    column: fallbackField.column
                                }, turnId);
                            }
                        }
                        return;
                    } else {
                        // Erster Wurf - verwende firstRollDice für Spalte 4
                        const col4Score = calculateScore(decision.details.category, firstRollDice);
                        if (col4Score > 0) {
                            // Temporär die Würfel für die Berechnung setzen
                            const originalDice = [...state.dice];
                            state.dice = [...firstRollDice];
                            
                            await executeComputerMoveNew({
                                type: 'EINTRAGEN',
                                category: decision.details.category,
                                column: decision.details.column
                            }, turnId);
                            
                            // Würfel zurücksetzen
                            state.dice = [...originalDice];
                            return;
                        }
                    }
                } else {
                    // Normale Spalten - verwende aktuelle Würfel
                    await executeComputerMoveNew({
                        type: 'EINTRAGEN',
                        category: decision.details.category,
                        column: decision.details.column
                    }, turnId);
                    return;
                }
            } else if (decision.action === 'Streichen') {
                await executeComputerMoveNew({
                    type: 'STREICHEN',
                    category: decision.details.category,
                    column: decision.details.column
                }, turnId);
                return;
            } else if (decision.action === 'Weiterwürfeln') {
                state.kept = decision.details;
                render();
                
                // WICHTIG: Zeige gehaltene/nicht gehaltene Würfel für längere Zeit
                await new Promise(r => setTimeout(r, state.settings.aiDelayLong));
                
                // Überprüfe ob dieser Zug noch aktuell ist
                if (turnId !== state.turnId - 1) return;
                
                const diceToRollCount = state.kept.filter(k => !k).length;
                if (diceToRollCount === 0) {
                    // Alle Würfel behalten, beende den Zug sofort
                    rollsRemaining = 0;
                    state.rollsLeft = 0;
                    break;
                }
                
                rollsRemaining--;
                state.rollsLeft = rollsRemaining;
                state.hasRolledMoreThanOnce = true; // WICHTIG: Setze das Flag!
                
                // NÄCHSTER WURF - animiere und setze dann die Werte
                await animateAndRollDice(diceToRollCount);
                
                // WICHTIG: Würfel sind jetzt aufgedeckt
                state.gamePhase = 'afterRoll';
                render();
                
                // Speichere die neuen Würfelwerte NACH dem Aufdecken
                currentDice = [...state.dice];
                // firstRollDice NICHT überschreiben!

                // --- LOGGING: KI-Wurf (weitere Würfe) ---
                if (state.settings.logGame) {
                    state.gameLog.push({
                        type: 'roll',
                        player: 'computer',
                        dice: state.dice.slice(),
                        kept: state.kept.slice(),
                        turn: state.turn,
                        rollsLeft: state.rollsLeft,
                        timestamp: Date.now()
                    });
                }

                // WICHTIG: Zeige neue Würfelwerte für längere Zeit
                await new Promise(r => setTimeout(r, state.settings.aiDelayLong));
            } else {
                // Keine gültige Aktion gefunden, zwinge Schleifenende
                console.log('KI: Keine gültige Aktion, beende Würfe');
                rollsRemaining = 0;
                break;
            }
        }

        // Überprüfe ein letztes Mal ob dieser Zug noch aktuell ist
        if (turnId !== state.turnId - 1) return;

        // Nach allen Würfen: Finale Entscheidung treffen
        kiPlayer.scorecard = state.scores.computer;
        const finalDecision = kiPlayer.getBestAction(currentDice, 3);

        console.log('KI finale Entscheidung:', finalDecision);

        if (finalDecision.action === 'Eintragen' && finalDecision.details) {
            // SPEZIELLE BEHANDLUNG FÜR SPALTE 4 AUCH HIER
            if (finalDecision.details.column === 'col4' && state.hasRolledMoreThanOnce) {
                console.log('KI: Spalte 4 in finaler Entscheidung nach mehrfachem Würfeln gesperrt');
                // Streiche stattdessen
                const fallbackField = findAvailableFieldToStrike();
                if (fallbackField) {
                    await executeComputerMoveNew({
                        type: 'STREICHEN',
                        category: fallbackField.category,
                        column: fallbackField.column
                    }, turnId);
                }
                return;
            }
            
            await executeComputerMoveNew({
                type: 'EINTRAGEN',
                category: finalDecision.details.category,
                column: finalDecision.details.column
            }, turnId);
        } else if (finalDecision.action === 'Streichen' && finalDecision.details) {
            await executeComputerMoveNew({
                type: 'STREICHEN',
                category: finalDecision.details.category,
                column: finalDecision.details.column
            }, turnId);
        } else {
            // Fallback: Finde ein Feld zum Streichen
            console.log('KI: Fallback - suche Feld zum Streichen');
            const fallbackField = findAvailableFieldToStrike();
            if (fallbackField) {
                console.log('KI: Fallback-Feld gefunden:', fallbackField);
                await executeComputerMoveNew({
                    type: 'STREICHEN',
                    category: fallbackField.category,
                    column: fallbackField.column
                }, turnId);
            } else {
                console.error('KI: Kein Fallback-Feld verfügbar! Spiel möglicherweise zu Ende.');
                // Notfall: Beende den Zug trotzdem
                endTurn();
            }
        }
    }

});
</script>

</body>
</html>
